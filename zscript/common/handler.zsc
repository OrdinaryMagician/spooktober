// global data shared between maps, used for progression
Class SpooktoberGlobals : Thinker
{
	bool completion[18];
	int maptimes[2][18];
	int mapkills[2][18];
	int mapitems[2][18];
	int mapsecrets[2][18];
	bool hastalked, secretending;
	int stage;

	static void TalkedToFirstMonk()
	{
		let v = GetInstance();
		if ( !v ) return;
		v.hastalked = true;
	}

	static clearscope bool HasTalkedToFirstMonk()
	{
		let v = GetInstance();
		if ( !v ) return false;
		return v.hastalked;
	}

	static void MakeInstance()
	{
		let t = ThinkerIterator.Create("SpooktoberGlobals",STAT_STATIC);
		let vars = SpooktoberGlobals(t.Next());
		if ( vars ) return;
		vars = new("SpooktoberGlobals");
		vars.ChangeStatNum(STAT_STATIC);
	}

	static clearscope SpooktoberGlobals GetInstance()
	{
		let t = ThinkerIterator.Create("SpooktoberGlobals",STAT_STATIC);
		let vars = SpooktoberGlobals(t.Next());
		return vars;
	}

	static void SetCompletion( int n )
	{
		if ( (n < 0) || (n > 17) ) return;
		let v = GetInstance();
		if ( !v ) return;
		v.completion[n] = true;
		// store the stats
		v.maptimes[n][0] = level.maptime/Thinker.TICRATE;
		v.maptimes[n][1] = level.partime/Thinker.TICRATE;
		v.mapkills[n][0] = level.killed_monsters;
		v.mapkills[n][1] = level.total_monsters;
		v.mapitems[n][0] = level.found_items;
		v.mapitems[n][1] = level.total_items;
		v.mapsecrets[n][0] = level.found_secrets;
		v.mapsecrets[n][1] = level.total_secrets;
		if ( (n <= 12) && GetFullCompletion(4) ) v.stage = max(5,v.stage);
		else if ( (n <= 11) && GetFullCompletion(3) ) v.stage = max(4,v.stage);
		else if ( (n <= 8) && GetFullCompletion(2) ) v.stage = max(3,v.stage);
		else if ( (n <= 5) && GetFullCompletion(1) ) v.stage = max(2,v.stage);
		else if ( (n <= 2) && GetFullCompletion(0) ) v.stage = max(1,v.stage);
	}

	static clearscope bool GetCompletion( int n )
	{
		let v = GetInstance();
		if ( !v ) return false;
		return v.completion[n];
	}

	static clearscope int, int GetTimes( int n )
	{
		let v = GetInstance();
		if ( !v ) return 0, 0;
		return v.maptimes[n][0], v.maptimes[n][1];
	}

	static clearscope int, int GetKills( int n )
	{
		let v = GetInstance();
		if ( !v ) return 0, 0;
		return v.mapkills[n][0], v.mapkills[n][1];
	}

	static clearscope int, int GetItems( int n )
	{
		let v = GetInstance();
		if ( !v ) return 0, 0;
		return v.mapitems[n][0], v.mapitems[n][1];
	}

	static clearscope int, int GetSecrets( int n )
	{
		let v = GetInstance();
		if ( !v ) return 0, 0;
		return v.mapsecrets[n][0], v.mapsecrets[n][1];
	}

	static clearscope bool GetFullCompletion( int n )
	{
		let v = GetInstance();
		if ( n == 0 )	// foyer
			return (v.completion[0]&&v.completion[1]&&v.completion[2]);
		else if ( n == 1 )	// east wing
			return (v.completion[3]&&v.completion[4]&&v.completion[5]);
		else if ( n == 2 )	// west wing
			return (v.completion[6]&&v.completion[7]&&v.completion[8]);
		else if ( n == 3 )	// second floor
			return (v.completion[9]&&v.completion[10]&&v.completion[11]);
		else if ( n == 4 )	// basement (final boss)
			return (v.completion[12]);
		else if ( n == 5 )	// secret maps (SECRET05 is optional)
			return (v.completion[13]&&v.completion[14]&&v.completion[15]&&v.completion[16]);
		return false;
	}

	static clearscope int GetStage()
	{
		let v = GetInstance();
		if ( !v ) return -1;
		return v.stage;
	}
}

// main handler of various events
Class SpooktoberHandler : EventHandler
{
	transient FLineTraceData tdata;
	double fspeed;
	int fphase, ftic;
	transient ui Font titlefont, authorfont, statsfont;

	override void OnRegister()
	{
		// initialize globals
		SpooktoberGlobals.MakeInstance();
	}

	override void WorldLinePreActivated( WorldEvent e )
	{
		if ( level.levelnum != 1 ) return;
		// prevent transition doors from being activated while in use
		if ( (e.ActivatedLine.special != 226) || (e.ActivatedLine.args[0] != 21) ) return;
		if ( e.Thing.player && e.Thing.player.cheats&CF_TOTALLYFROZEN ) e.ShouldActivate = false;
	}

	override void WorldTick()
	{
		if ( fspeed > double.epsilon )
		{
			double str = (gametic-ftic)/(Thinker.TICRATE*fspeed);
			if ( str > 1.0 )
			{
				Shader.SetEnabled(players[consoleplayer],"blurfade",false);
				fspeed = 0;
			}
		}
		if ( level.levelnum != 1 ) return;
		// trace from consoleplayer and see what hits
		PlayerPawn mo = players[consoleplayer].mo;
		mo.LineTrace(mo.angle,140,mo.pitch,TRF_THRUACTORS,mo.viewheight,data:tdata);
	}

	override void RenderOverlay( RenderEvent e )
	{
		// fader shader
		if ( fspeed > double.epsilon )
		{
			PlayerInfo p = players[consoleplayer];
			double str = clamp(((gametic-ftic)+e.fractic)/(Thinker.TICRATE*fspeed),0.0,1.0);
			if ( fphase ) str = 1.0-str;
			Shader.SetUniform1f(p,"blurfade","strength",str);
		}
		if ( level.levelnum != 1 ) return;
		if ( automapactive ) return;
		// check that we're tracing the midtex of a level painting
		if ( (tdata.HitType != TRACE_HitWall) || (tdata.LinePart != 1) || (tdata.HitLine.special != 80) || (tdata.HitLine.args[0] != 10) ) return;
		// get map name from levelnum
		String mname = "???";
		if ( (tdata.HitLine.args[2] >= 2) && (tdata.HitLine.args[2] <= 14) )
			mname = StringTable.Localize(String.Format("$SP_SPOOK%02d",tdata.HitLine.args[2]-1));
		else if ( (tdata.HitLine.args[2] >= 15) && (tdata.HitLine.args[2] <= 19) )
			mname = StringTable.Localize(String.Format("$SP_SECRET%02d",tdata.HitLine.args[2]-14));
		double ypos;
		if ( SpooktoberGlobals.GetCompletion(tdata.HitLine.args[2]-2) ) ypos = 110.;
		else ypos = 150.;
		int len;
		if ( !titlefont ) titlefont = Font.GetFont('GRGW_LWR');
		if ( !authorfont ) authorfont = Font.GetFont('GARGSMAL');
		if ( !statsfont ) statsfont = Font.GetFont('DietLogFont');
		// format name
		if ( mname.IndexOf(" - by: ") != -1 )
		{
			Array<String> fname;
			mname.Split(fname," - by: ");
			len = titlefont.StringWidth(fname[0]);
			Screen.DrawText(titlefont,Font.CR_RED,(320.-len)/2.,ypos,fname[0],DTA_Bottom320x200,true);
			ypos += titlefont.GetHeight()+2;
			len = authorfont.StringWidth(fname[1]);
			Screen.DrawText(authorfont,Font.CR_WHITE,(320.-len)/2.,ypos,fname[1],DTA_Bottom320x200,true);
			ypos += authorfont.GetHeight()+6;
		}
		else
		{
			len = titlefont.StringWidth(mname);
			Screen.DrawText(titlefont,Font.CR_RED,(320.-len)/2.,ypos,mname,DTA_Bottom320x200,true);
			ypos += titlefont.GetHeight()+6;
		}
		if ( SpooktoberGlobals.GetCompletion(tdata.HitLine.args[2]-2) )
		{
			len = statsfont.StringWidth("[Cleared]");
			Screen.DrawText(statsfont,Font.CR_GOLD,(320.-len)/2.,ypos,"[Cleared]",DTA_Bottom320x200,true);
			ypos += statsfont.GetHeight()+4;
			int maxlen = 0, h1, m1, s1, h2, m2, s2, ki1, ki2, it1, it2, sc1, sc2;
			String ctime, ptime, ckills, citems, csecrets;
			[s1, s2] = SpooktoberGlobals.GetTimes(tdata.HitLine.args[2]-2);
			[ki1, ki2] = SpooktoberGlobals.GetKills(tdata.HitLine.args[2]-2);
			[it1, it2] = SpooktoberGlobals.GetItems(tdata.HitLine.args[2]-2);
			[sc1, sc2] = SpooktoberGlobals.GetSecrets(tdata.HitLine.args[2]-2);
			h1 = s1/3600;
			m1 = (s1%3600)/60;
			s1 = s1%60;
			h2 = s2/3600;
			m2 = (s2%3600)/60;
			s2 = s2%60;
			if ( h1 > 0 ) ctime = String.Format("%02d:%02d:%02d",h1,m1,s1);
			else ctime = String.Format("%02d:%02d",m1,s1);
			if ( h2 > 0 ) ptime = String.Format("%02d:%02d:%02d",h2,m2,s2);
			else ptime = String.Format("%02d:%02d",m2,s2);
			len = statsfont.StringWidth("Time: "..ctime);
			if ( len > maxlen ) maxlen = len;
			len = statsfont.StringWidth("Par: "..ptime);
			if ( len > maxlen ) maxlen = len;
			ckills = String.Format("%d/%d",ki1,ki2);
			len = statsfont.StringWidth("Kills: "..ckills);
			if ( len > maxlen ) maxlen = len;
			citems = String.Format("%d/%d",it1,it2);
			len = statsfont.StringWidth("Items: "..citems);
			if ( len > maxlen ) maxlen = len;
			csecrets = String.Format("%d/%d",sc1,sc2);
			len = statsfont.StringWidth("Secrets: "..csecrets);
			if ( len > maxlen ) maxlen = len;
			Screen.DrawText(statsfont,Font.CR_RED,(320.-maxlen)/2.,ypos,"Time:",DTA_Bottom320x200,true);
			len = statsfont.StringWidth(ctime);
			Screen.DrawText(statsfont,Font.CR_WHITE,(320.+maxlen)/2.-len,ypos,ctime,DTA_Bottom320x200,true);
			ypos += statsfont.GetHeight();
			Screen.DrawText(statsfont,Font.CR_RED,(320.-maxlen)/2.,ypos,"Par:",DTA_Bottom320x200,true);
			len = statsfont.StringWidth(ptime);
			Screen.DrawText(statsfont,Font.CR_WHITE,(320.+maxlen)/2.-len,ypos,ptime,DTA_Bottom320x200,true);
			ypos += statsfont.GetHeight();
			Screen.DrawText(statsfont,Font.CR_RED,(320.-maxlen)/2.,ypos,"Kills:",DTA_Bottom320x200,true);
			len = statsfont.StringWidth(ckills);
			Screen.DrawText(statsfont,Font.CR_WHITE,(320.+maxlen)/2.-len,ypos,ckills,DTA_Bottom320x200,true);
			ypos += statsfont.GetHeight();
			Screen.DrawText(statsfont,Font.CR_RED,(320.-maxlen)/2.,ypos,"Items:",DTA_Bottom320x200,true);
			len = statsfont.StringWidth(citems);
			Screen.DrawText(statsfont,Font.CR_WHITE,(320.+maxlen)/2.-len,ypos,citems,DTA_Bottom320x200,true);
			ypos += statsfont.GetHeight();
			Screen.DrawText(statsfont,Font.CR_RED,(320.-maxlen)/2.,ypos,"Secrets:",DTA_Bottom320x200,true);
			len = statsfont.StringWidth(csecrets);
			Screen.DrawText(statsfont,Font.CR_WHITE,(320.+maxlen)/2.-len,ypos,csecrets,DTA_Bottom320x200,true);
		}
		else
		{
			len = statsfont.StringWidth("[Not cleared]");
			Screen.DrawText(statsfont,Font.CR_BLACK,(320.-len)/2.,ypos,"[Not cleared]",DTA_Bottom320x200,true);
		}
	}

	override void WorldUnloaded( WorldEvent e )
	{
		Shader.SetEnabled(players[consoleplayer],"blurfade",false);
		SpooktoberGlobals.SetCompletion(level.levelnum-2);
		if ( level.levelnum != 1 ) return;
		// adjust player sizes back to normal
		// there's no "PlayerLeft" event so it has to be done here
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] ) continue;
			let mo = players[i].mo;
			let d = GetDefaultByType(mo.GetClass());
			mo.A_SetSize(d.radius,d.height);
			mo.scale = d.scale;
			mo.player.viewheight = mo.viewheight = d.viewheight;
			mo.viewbob = d.viewbob;
		}
	}

	override void PlayerEntered( PlayerEvent e )
	{
		// loadout management
		let mo = players[e.playernumber].mo;
		mo.Health = mo.SpawnHealth();
		mo.ClearInventory();
		switch ( level.levelnum )
		{
		case 1:
			// you get nothing
			break;
		case 17:
			// fist only
			mo.GiveInventory("Fist",1);
			break;
		default:
			// give start items for player pawn (this allows mod support)
			SpooktoberUtil.GiveStartItems(mo);
			break;
		}
		if ( level.levelnum != 1 ) return;
		// adjust player size (too lazy to rescale map itself)
		let d = GetDefaultByType(mo.GetClass());
		mo.A_SetSize(d.radius*1.3,d.height*1.4);
		mo.scale = d.scale*1.4;
		mo.player.viewheight = mo.viewheight = 65;
		mo.viewbob = d.viewbob*0.5;
		// footsteps!
		mkFootstepMaker.AttachTo(mo);
	}

	static void FadeInShader( double speed = 1.0 )
	{
		let hnd = SpooktoberHandler(EventHandler.Find("SpooktoberHandler"));
		if ( !hnd ) return;
		hnd.fspeed = speed;
		hnd.fphase = 1;
		hnd.ftic = gametic;
		Shader.SetEnabled(players[consoleplayer],"blurfade",true);
	}

	static void FadeOutShader( double speed = 1.0 )
	{
		let hnd = SpooktoberHandler(EventHandler.Find("SpooktoberHandler"));
		if ( !hnd ) return;
		hnd.fspeed = speed;
		hnd.fphase = 0;
		hnd.ftic = gametic;
		Shader.SetEnabled(players[consoleplayer],"blurfade",true);
	}
}
