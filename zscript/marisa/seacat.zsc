// Umineko-style fade effect
Class mkSeacatFade : Actor
{
	double i;

	Default
	{
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
		Radius 16;
		Height 56;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_PlaySound("seacat/z1");
		i = 0;
		if ( target ) A_SetSize(target.radius,target.height);
	}
	override void Tick()
	{
		Super.Tick();
		if ( target ) SetOrigin(target.pos,true);
		double a, s;
		Vector2 spot;
		int l2 = int(i);
		double step = 3*(height/56.);
		double al = i/double(height);
		for ( int l=0; l<=l2; l++ )
		{
			for ( int j=0; j<(radius/8); j++ )
			{
				a = FRandom[Butterflies](0,360);
				s = FRandom[Butterflies](0,radius);
				spot = (cos(a),sin(a));
				A_SpawnParticle("FF FF FF",SPF_FULLBRIGHT,Random[Butterflies](30,50),8,0,spot.x*s,spot.y*s,l+FRandom[Butterflies](-4,4),accelx:FRandom[Butterflies](0.03,0.06)+spot.x*0.02,accely:spot.y*0.02,accelz:0.04,startalphaf:al);
			}
		}
		if ( (i+=step) >= height ) Destroy();
	}
}

Class mkDialogueSequence40 : mkDialogueSequence
{
	override void DialogueSeq( int state )
	{
		switch( state )
		{
		case 0:
			SetHeader("??????");
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			StartText("$BEATDLG1");
			break;
		case 1:
			StartText("$BEATDLG2");
			break;
		case 2:
			StartText("$BEATDLG3");
			break;
		case 3:
			StartText("$BEATDLG4");
			break;
		case 4:
			SetHeader("$BEATHDR");
			EventHandler.SendNetworkEvent("setspeakerframe",3);
			StartText("$BEATDLG5");
			break;
		case 5:
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			StartText("$BEATDLG6");
			break;
		case 6:
			EventHandler.SendNetworkEvent("setspeakerframe",3);
			StartText("$BEATDLG7");
			break;
		case 7:
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			StartText("$BEATDLG8");
			break;
		case 8:
			EventHandler.SendNetworkEvent("setspeakerframe",5);
			StartText("$BEATDLG9");
			break;
		case 9:
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			StartText("$BEATDLG10");
			break;
		case 10:
			EventHandler.SendNetworkEvent("setspeakerframe",3);
			StartText("$BEATDLG11");
			break;
		case 11:
			EventHandler.SendNetworkEvent("setspeakerframe",8);
			S_Sound("seacat/ahahawav",CHAN_VOICE,1.0,ATTN_NONE);
			SetTextSpeed(2);
			SetTextEffect(TE_SHIVER);
			StartText("$BEATDLG12");
			break;
		case 12:
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			SetTextSpeed(1);
			SetTextEffect(TE_NONE);
			StartText("$BEATDLG13");
			break;
		case 13:
			EventHandler.SendNetworkEvent("setspeakerframe",3);
			EventHandler.SendNetworkEvent("giveshotty");
			StartText("$BEATDLG14");
			break;
		case 14:
			StartText("$BEATDLG15");
			break;
		case 15:
			StartText("$BEATDLG16");
			break;
		case 16:
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			StartText("$BEATDLG17");
			break;
		case 17:
			StartText("$BEATDLG18");
			break;
		case 18:
			EventHandler.SendNetworkEvent("setspeakerframe",8);
			SetTextSpeed(2);
			SetTextEffect(TE_SHIVER);
			StartText("$BEATDLG19");
			break;
		case 19:
			EventHandler.SendNetworkEvent("setspeakerframe",1);
			S_Sound("seacat/ahahawav",CHAN_VOICE,1.0,ATTN_NONE);
			EventHandler.SendNetworkEvent("activategoats");
			EndSeq(0);
			break;
		}
	}
}

Class mkDialogueSequence41 : mkDialogueSequence
{
	override void DialogueSeq( int state )
	{
		switch( state )
		{
		case 0:
			SetHeader("$BEATHDR");
			EventHandler.SendNetworkEvent("setspeakerframe",2);
			StartText("$BEATDLG20");
			break;
		case 1:
			EventHandler.SendNetworkEvent("setspeakerframe",6);
			StartText("$BEATDLG21");
			break;
		case 2:
			StartText("$BEATDLG22");
			break;
		case 3:
			EventHandler.SendNetworkEvent("setspeakerframe",7);
			StartText("$BEATDLG23");
			break;
		case 4:
			EventHandler.SendNetworkEvent("setspeakerframe",4);
			StartText("$BEATDLG24");
			break;
		case 5:
			EventHandler.SendNetworkEvent("setspeakerframe",2);
			StartText("$BEATDLG25");
			break;
		case 6:
			EventHandler.SendNetworkEvent("setspeakerframe",0);
			StartText("$BEATDLG26");
			break;
		case 7:
			EventHandler.SendNetworkEvent("setspeakerframe",9);
			SetTextSpeed(0);
			SetVoice("");
			S_Sound("seacat/redtext",CHAN_WEAPON,1.0,ATTN_NONE);
			StartText("$BEATDLG27");
			break;
		case 8:
			EventHandler.SendNetworkEvent("setspeakerframe",1);
			S_Sound("seacat/ahahawav",CHAN_VOICE,1.0,ATTN_NONE);
			EventHandler.SendNetworkEvent("secret05exit");
			EndSeq(0);
			break;
		}
	}
}

// dialogue npc
Class mkBeatrice : Actor
{
	override void Activate( Actor activator )
	{
		if ( !score )
		{
			SetStateLabel("FadeOut");
			return;
		}
		mkDialogueHandler.StartDialogueSequence(self,activator,score);
	}
	Default
	{
		RenderStyle "Translucent";
		Alpha 0;
		Radius 8;
		Height 56;
		Scale 0.056;
	}
	override void PostBeginPlay()
	{
		let s = Spawn("mkSeacatFade");
		s.target = self;
	}
	States
	{
	Spawn:
		BEAT F 1;
		BEAT F 1
		{
			if ( score == 41 )
				frame = 4;
		}
		BEAT # 1 A_FadeIn(0.02,FTF_CLAMP);
		BEAT # 0 A_JumpIf(alpha>=1,1);
		Goto Spawn+2;
		BEAT # -1;
		Stop;
	FadeOut:
		BEAT # 0
		{
			let s = Spawn("mkSeacatFade");
			s.target = self;
		}
		BEAT # 1 A_FadeOut(0.02);
		Wait;
	Cache:
		BEAT ABCDEFGHI 0;
		Stop;
	}
}

Class mkPoof : Actor
{
	Default
	{
		RenderStyle "Translucent";
		Scale 1.2;
		Alpha 0.5;
		+FORCEXYBILLBOARD;
		+NOBLOCKMAP;
		+NOGRAVITY;
	}
	States
	{
	Spawn:
		FX04 BCDEF 5;
		Stop;
	}
}

// all of the goats
Class mkGoatBall : Actor
{
	Default
	{
		Scale 1.2;
		Radius 6;
		Height 16;
		Speed 15;
		DamageFunction Random[Goat](4,6)*3;
		DamageType "Magic";
		PROJECTILE;
		+RANDOMIZE;
		+THRUSPECIES;
		Species "Goat";
		RenderStyle "Add";
		SeeSound "baron/attack";
		DeathSound "baron/shotx";
		Obituary "%o was burned to ashes by a goat servant.";
	}
	States
	{
	Spawn:
		BALG AB 4 BRIGHT;
		Loop;
	Death:
		BALG CDE 6 BRIGHT;
		Stop;
	}
}

Class mkLesserGoatServant : Actor
{
	int sct;
	double bstr;

	override String GetObituary( Actor victim, Actor inflictor, Name mod, bool playerattack )
	{
		if ( mod == 'Slam' ) return "%o was headbutted by a goat servant.";
		return HitObituary;
	}

	Default
	{
		MONSTER;
		-SHOOTABLE;
		+LOOKALLAROUND;
		Species "LesserGoat";
		RenderStyle "Translucent";
		DamageFactor "Magic", 0;
		DamageFactor "AntiMagic", 999999999;
		Alpha 0;
		Health 100;
		PainChance 150;
		Scale 0.8;
		Radius 14;
		Height 56;
		Speed 12;
		Mass 120;
		MeleeRange 50;
		SeeSound "satyr/see";
		ActiveSound "knight/active";
		PainSound "knight/pain";
		DeathSound "satyr/die";
		HitObituary "%o was torn to shreds by a goat servant.";
	}
	override void PostBeginPlay()
	{
		let s = Spawn("mkSeacatFade");
		s.target = self;
	}
	// turns out it can not be blocking
	bool BlockingLineIsBlocking()
	{
		if ( !BlockingLine ) return false;
		// one-sided
		if ( !BlockingLine.sidedef[1] ) return true;
		// blocks us
		if ( BlockingLine.flags&(Line.ML_BLOCKING|Line.ML_BLOCKMONSTERS|Line.ML_BLOCKEVERYTHING) ) return true;
		return false;
	}
	void A_GoatAttack()
	{
		if ( !target || !CheckMeleeRange() ) return;
		int damage = random[Goat](2,3)*2;
		A_PlaySound("imp/melee",CHAN_WEAPON);
		int newdam = target.DamageMobj(self,self,damage,'Melee');
		target.TraceBleed(newdam>0?newdam:damage,self);
		Vector2 bleeddir = target.Vec2To(self).unit();
		Vector3 bleedpos = target.pos+((cos(bleeddir.x)+sin(bleeddir.y))*target.radius,(sin(bleeddir.x)-cos(bleeddir.y))*target.radius,target.height*0.5);
		target.SpawnBlood(bleedpos,atan2(bleeddir.y,bleeddir.x),newdam>0?newdam:damage);
	}
	bool A_LungeAtTarget( bool test = false )
	{
		if ( !target ) return false;
		gravity = 0.65;
		double grav = gravity*cursector.gravity;
		double flyspeed = clamp(Distance2D(target)*0.05,20,50);
		double x = Distance2D(target)-target.radius, y = target.pos.z-pos.z;
		double ds = flyspeed**4-grav*(grav*x*x+2*y*flyspeed**2);
		double spitch;
		if ( ds > 0 )
		{
			double a1, a2, high, low, maxht;
			a1 = atan((flyspeed**2+sqrt(ds))/(grav*x));
			a2 = atan((flyspeed**2-sqrt(ds))/(grav*x));
			if ( a1 < a2 )
			{
				low = a1;
				high = a2;
			}
			else
			{
				low = a2;
				high = a1;
			}
			// use lower pitch unless it's zero or negative
			if ( low <= 0 ) spitch = -high;
			else spitch = -low;
		}
		else spitch = 10;
		if ( test )
		{
			gravity = 1.0;
			return (spitch < 40);
		}
		A_FaceTarget(30);
		vel = flyspeed*(cos(angle)*cos(spitch),sin(angle)*cos(spitch),sin(-spitch));
		vel.z += 1;
		for ( int i=0; i<360; i+=30 )
		{
			let p = Spawn("mkPoof",pos);
			p.vel.xy = (cos(i),sin(i))*5;
		}
		A_PlaySound("goat/thump",CHAN_7,0.5);
		return true;
	}
	void A_CheckLunge( bool alt = false )
	{
		// reorient
		if ( target )
		{
			A_FaceTarget(1);
			vel.xy = (cos(angle),sin(angle))*vel.length();
		}
		bool dummy;
		Actor onmobj;
		[dummy, onmobj] = TestMobjZ(true);
		if ( !CheckMeleeRange() && !BlockingMobj && !BlockingLineIsBlocking() && (pos.z > floorz) && !onmobj ) return;
		gravity = 1;
		Actor hitactor;
		if ( CheckMeleeRange() ) hitactor = target;
		else hitactor = BlockingMobj?BlockingMobj:onmobj;
		if ( hitactor && hitactor.bSOLID )
		{
			int dmg = Random[Goat](4,6);
			if ( hitactor is 'mkGoatServant' ) dmg = 0;
			if ( hitactor.bSHOOTABLE )
			{
				hitactor.DamageMobj(self,self,dmg,'Slam',DMG_THRUSTLESS);
				Vector3 dirto = Vec3To(hitactor).unit();
				hitactor.vel.xy = dirto.xy*(1000./hitactor.mass);
				hitactor.vel.z = (500./hitactor.mass);
			}
			if ( !hitactor.bSHOOTABLE || hitactor.bNOBLOOD ) A_PlaySound("goat/hitwall",CHAN_6);
			else A_PlaySound("goat/hit",CHAN_6);
			if ( alt ) SetStateLabel("Melee2_");
			else SetStateLabel("Melee__");
		}
		else if ( BlockingLineIsBlocking() )
		{
			A_PlaySound("goat/hitwall",CHAN_6);
			vel.xy = RotateVector((-4,0),angle);
			vel.z = 3;
			SetStateLabel("PainRecoil");
		}
		else SetStateLabel("Brake");
	}

	States
	{
	Spawn:
		LGOA A 1 A_FadeIn(0.04,FTF_CLAMP);
		LGOA A 0 A_JumpIf(alpha>=1,"Idle");
		Loop;
	Idle:
		LGOA A 0 { bSHOOTABLE = true; sct = 0; }
		LGOA AABBCCDD 4
		{
			if ( !(sct%4) )
				A_PlaySound("satyr/step",CHAN_7,0.4,false,2.0);
			sct++;
			A_Wander();
			A_Look();
		}
		Goto Idle+1;
		Wait;
	See:
		LGOA A 0 { sct = 0; }
		LGOA AABBCCDD 3
		{
			if ( !(sct%4) )
				A_PlaySound("satyr/step",CHAN_7,0.4,false,2.0);
			sct++;
			A_Chase();
			if ( !target || (target.Health <= 0) )
				return ResolveState(null);
			double targetdist = Vec2To(target).length();
			if ( CheckIfTargetInLOS(360) && (targetdist > 500) && (Random[Goat]() < 12) && A_LungeAtTarget(true) )
			{
				FLineTraceData d;
				LineTrace(AngleTo(target),Vec2To(target).length(),0,TRF_SOLIDACTORS,16,0,0,data:d);
				if ( (d.HitType == TRACE_HitNone) || ((d.HitType == TRACE_HitActor) && (d.HitActor == target)) )
					return ResolveState("Lunge");
			}
			return ResolveState(null);
		}
		Goto See+1;
	Lunge:
		LGOA A 0
		{
			A_PlaySound(SeeSound,CHAN_VOICE);
			A_FaceTarget();
		}
		LGOA AAA 5 A_FaceTarget(15);
		LGOA A 0 A_Jump(128,"Lunge2");
		LGOA F 5 A_LungeAtTarget();
		LGOA E 1 A_CheckLunge();
		Goto Lunge+6;
	Lunge2:
		LGOA Q 5 A_LungeAtTarget();
		LGOA P 1 A_CheckLunge(true);
		Goto Lunge2+1;
	Melee:
		LGOA F 0 A_Jump(128,"Melee2");
	Melee_:
		LGOA F 3 { A_FaceTarget(); A_Recoil(-1.0); }
		LGOA E 3 A_FaceTarget();
	Melee__:
		LGOA F 3 A_FaceTarget();
		LGOA G 4 A_GoatAttack();
		LGOA F 2;
		LGOA F 0 A_JumpIf(!CheckMeleeRange()||!target||(target.health<=0),"See");
		Goto Melee2;
	Melee2:
		LGOA Q 3 { A_FaceTarget(); A_Recoil(-1.0); }
		LGOA P 3 A_FaceTarget();
	Melee2_:
		LGOA Q 3 A_FaceTarget();
		LGOA R 4 A_GoatAttack();
		LGOA Q 2;
		LGOA Q 0 A_JumpIf(!CheckMeleeRange()||!target||(target.health<=0),"See");
		Goto Melee+1;
	Brake:
		LGOA A 0
		{
			sct = 0;
			bstr = vel.xy.length()*0.6;
			vel.xy = RotateVector((bstr,0),angle);
			A_PlaySound("satyr/step",CHAN_7);
			if ( bstr > 1 ) A_PlaySound("goat/brake",CHAN_5);
		}
		LGOA A 1
		{
			Actor hitactor;
			if ( CheckMeleeRange() ) hitactor = target;
			else hitactor = BlockingMobj;
			if ( hitactor && hitactor.bSOLID )
			{
				int dmg = Random[Goat](3,5);
				if ( hitactor is 'mkGoatServant' ) dmg = 0;
				if ( hitactor.bSHOOTABLE )
				{
					hitactor.DamageMobj(self,self,dmg,'Slam',DMG_THRUSTLESS);
					Vector3 dirto = Vec3To(hitactor).unit();
					hitactor.vel.xy = dirto.xy*(500./hitactor.mass);
					hitactor.vel.z = (300./hitactor.mass);
				}
				if ( !hitactor.bSHOOTABLE || hitactor.bNOBLOOD ) A_PlaySound("goat/hitwall",CHAN_6);
				else A_PlaySound("goat/hit",CHAN_6);
				vel.xy = RotateVector((-4,0),angle);
				vel.z = 3;
				return ResolveState("Recoil");
			}
			if ( BlockingLineIsBlocking() )
			{
				A_PlaySound("goat/hitwall",CHAN_6);
				vel.xy = RotateVector((-4,0),angle);
				vel.z = 3;
				return ResolveState("PainRecoil");
			}
			if ( !(sct%3) && (vel.length() > 2) )
			{
				Vector3 ofs = (0,0,8);
				ofs.xy = RotateVector((8,0),angle+90);
				Spawn("mkPoof",pos+ofs);
				ofs.xy = RotateVector((8,0),angle-90);
				Spawn("mkPoof",pos+ofs);
			}
			sct++;
			A_FaceTarget(3);
			vel.xy = vel.xy*0.8+RotateVector((bstr,0)*0.2,angle);
			bstr *= 0.95;
			if ( vel.xy.length() <= 1 ) return ResolveState("See");
			return ResolveState(null);
		}
		Wait;
	Pain:
		LGOA H 5
		{
			gravity = 1;
			A_Pain();
		}
		Goto See;
	Recoil:
		LGOA A 0 { gravity = 1; }
		LGOA A 30;
		LGOA A 1 A_JumpIf(vel.length()<1,"See");
		Wait;
	PainRecoil:
		LGOA H 0 { gravity = 1; }
		LGOA H 10 A_Pain();
		LGOA A 20;
		LGOA A 1 A_JumpIf(vel.length()<1,"See");
		Wait;
	Death:
		LGOA I 5 { gravity = 1; A_NoBlocking(); }
		LGOA J 5 A_Scream();
		LGOA KL 4;
		LGOA M 3 A_QuakeEx(2,2,2,10,0,300,"",QF_RELATIVE|QF_SCALEDOWN,falloff:100);
		LGOA N 3 A_PlaySound("goat/thump",CHAN_7,0.5);
		LGOA O 120;
		LGOA O 0
		{
			let s = Spawn("mkSeacatFade",pos);
			s.target = self;
		}
		LGOA O 1 A_FadeOut(0.04);
		Wait;
	}
}

Class mkGoatServant : Actor
{
	int chargetimer, sct;
	double bstr;

	override String GetObituary( Actor victim, Actor inflictor, Name mod, bool playerattack )
	{
		if ( mod == 'Slam' ) return "%o sucks at bullfighting.";
		return HitObituary;
	}

	Default
	{
		MONSTER;
		-SHOOTABLE;
		+NOINFIGHTSPECIES;
		+LOOKALLAROUND;
		Species "Goat";
		RenderStyle "Translucent";
		DamageFactor "Magic", 0;
		DamageFactor "AntiMagic", 999999999;
		Alpha 0;
		Health 200;
		PainChance 100;
		Scale 1.2;
		Radius 22;
		Height 84;
		Speed 15;
		Mass 300;
		MeleeRange 50;
		SeeSound "knight/sight";
		ActiveSound "knight/active";
		PainSound "knight/pain";
		DeathSound "knight/death";
		HitObituary "%o was torn to shreds by a goat servant.";
	}
	bool CheckFall()
	{
		// advanced stuff for checking if the goat will run into the void and die
		Vector3 oldpos = pos;
		double angdest = AngleTo(target);
		Vector2 dir = (cos(angdest),sin(angdest));
		for ( int i=0; i<25; i++ )
		{
			if ( !TryMove(Vec2Offset(dir.x*25,dir.y*25),int(maxdropoffheight)) )
				break;
			if ( floorpic == skyflatnum )
			{
				SetOrigin(oldpos,false);
				return true;
			}
		}
		SetOrigin(oldpos,false);
		return false;
	}
	override void PostBeginPlay()
	{
		let s = Spawn("mkSeacatFade");
		s.target = self;
	}
	override void Tick()
	{
		Super.Tick();
		if ( InStateSequence(CurState,ResolveState("Charge")) ) speed = 25;
		else speed = 15;
	}
	void A_GoatAttack()
	{
		if ( !target || !CheckMeleeRange() ) return;
		int damage = random[Goat](2,3)*5;
		A_PlaySound("imp/melee",CHAN_WEAPON);
		int newdam = target.DamageMobj(self,self,damage,'Melee');
		target.TraceBleed(newdam>0?newdam:damage,self);
		Vector2 bleeddir = target.Vec2To(self).unit();
		Vector3 bleedpos = target.pos+((cos(bleeddir.x)+sin(bleeddir.y))*target.radius,(sin(bleeddir.x)-cos(bleeddir.y))*target.radius,target.height*0.5);
		target.SpawnBlood(bleedpos,atan2(bleeddir.y,bleeddir.x),newdam>0?newdam:damage);
	}
	void A_GoatAttack2()
	{
		if ( !target ) return;
		SpawnMissile(target,"mkGoatBall");
		if ( CheckMeleeRange() )
		{
			int damage = random[Goat](2,3)*6;
			A_PlaySound("imp/melee",CHAN_WEAPON);
			int newdam = target.DamageMobj(self,self,damage,'Melee');
			target.TraceBleed(newdam>0?newdam:damage,self);
			Vector2 bleeddir = target.Vec2To(self).unit();
			Vector3 bleedpos = target.pos+((cos(bleeddir.x)+sin(bleeddir.y))*target.radius,(sin(bleeddir.x)-cos(bleeddir.y))*target.radius,target.height*0.5);
			target.SpawnBlood(bleedpos,atan2(bleeddir.y,bleeddir.x),newdam>0?newdam:damage);
		}
	}
	States
	{
	Spawn:
		GOAT A 1 A_FadeIn(0.04,FTF_CLAMP);
		GOAT A 0 A_JumpIf(alpha>=1,"Idle");
		Loop;
	Idle:
		GOAT A 0 { bSHOOTABLE = true; sct = 0; }
		GOAT AABBCCDD 4
		{
			if ( !(sct%4) )
			{
				A_QuakeEx(3,3,3,8,0,200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:100);
				A_PlaySound("goat/step",CHAN_7,0.1,false,2.0);
			}
			sct++;
			A_Wander();
			A_Look();
		}
		Goto Idle+1;
	See:
		GOAT A 0 { sct = 0; }
		GOAT AABBCCDD 3
		{
			if ( !(sct%4) )
			{
				A_QuakeEx(3,3,3,8,0,200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:100);
				A_PlaySound("goat/step",CHAN_7,0.1,false,2.0);
			}
			sct++;
			A_Chase();
			if ( !target || (target.Health <= 0) )
				return ResolveState(null);
			double targetdist = Vec2To(target).length();
			if ( CheckIfTargetInLOS(360) && (targetdist > 500) && (Random[Goat]() < 25) )
			{
				if ( CheckFall() )
					return ResolveState(null);
				FLineTraceData d;
				LineTrace(AngleTo(target),Vec2To(target).length(),0,TRF_SOLIDACTORS,16,0,0,data:d);
				if ( (d.HitType == TRACE_HitNone) || ((d.HitType == TRACE_HitActor) && (d.HitActor == target)) )
					return ResolveState("Charge");
			}
			return ResolveState(null);
		}
		Goto See+1;
	Charge:
		GOAT H 18
		{
			PainChance = 0;
			A_FaceTarget();
			A_PlaySound(SeeSound,CHAN_WEAPON);
			chargetimer = Random[Goat](15,25);
			sct = 0;
		}
		GOAT A 0 { PainChance = 30; }
		GOAT AABBCCDD 2
		{
			if ( Random[GoatMove]() < 3 ) PlayActiveSound();
			if ( !(sct%4) )
			{
				A_QuakeEx(4,4,4,8,0,400,"",QF_RELATIVE|QF_SCALEDOWN,falloff:150);
				A_PlaySound("goat/step",CHAN_7,0.4);
			}
			sct++;
			A_FaceTarget(3);
			Vector2 dir = (cos(angle),sin(angle));
			bool moved = TryMove(pos.xy+dir*speed,int(maxdropoffheight));
			if ( CheckMeleeRange() ) BlockingMobj = target;
			if ( BlockingMobj && BlockingMobj.bSOLID )
			{
				Actor victim = BlockingMobj;
				int dmg = Random[Goat](6,9)*4;
				if ( victim is 'mkGoatServant' ) dmg = 0;
				if ( victim.bSHOOTABLE )
				{
					victim.DamageMobj(self,self,dmg,'Slam',DMG_THRUSTLESS);
					Vector3 dirto = Vec3To(victim).unit();
					victim.vel.xy = dirto.xy*(2000./victim.mass);
					victim.vel.z = (900./victim.mass);
				}
				if ( !victim.bSHOOTABLE || victim.bNOBLOOD ) A_PlaySound("goat/hitwall",CHAN_6);
				else A_PlaySound("goat/hit",CHAN_6);
				A_QuakeEx(6,6,6,10,0,500,"",QF_RELATIVE|QF_SCALEDOWN,falloff:200);
				vel.xy = RotateVector((-8,0),angle);
				vel.z = 4;
				return ResolveState("Recoil");
			}
			if ( !moved )
			{
				A_PlaySound("goat/hitwall",CHAN_6);
				A_QuakeEx(6,6,6,10,0,500,"",QF_RELATIVE|QF_SCALEDOWN,falloff:200);
				vel.xy = RotateVector((-8,0),angle);
				vel.z = 4;
				return ResolveState("PainRecoil");
			}
			if ( abs(DeltaAngle(angle,AngleTo(target))) > 90 ) chargetimer = min(chargetimer,2);
			return ResolveState(null);
		}
		GOAT D 0
		{
			chargetimer--;
			if ( chargetimer <= 0 )
				return ResolveState("Brake");
			return ResolveState(null);
		}
		Goto Charge+1;
	Missile:
		GOA2 F 0 A_Jump(128,"Missile2");
	Missile_:
		GOA2 FEF 4 A_FaceTarget();
		GOA2 G 5 A_GoatAttack2();
		GOA2 F 3;
		GOA2 F 0 A_JumpIf(CheckMeleeRange(),"Melee2");
		GOA2 F 0 A_Jump(192,"See");
		GOA2 F 0 A_JumpIfTargetInLOS("Missile2");
		Goto See;
	Missile2:
		GOA2 QPQ 4 A_FaceTarget();
		GOA2 R 5 A_GoatAttack2();
		GOA2 Q 3;
		GOA2 Q 0 A_JumpIf(CheckMeleeRange(),"Melee_");
		GOA2 Q 0 A_Jump(192,"See");
		GOA2 Q 0 A_JumpIfTargetInLOS("Missile_");
		Goto See;
	Melee:
		GOAT F 0 A_Jump(128,"Melee2");
	Melee_:
		GOAT F 4 { A_FaceTarget(); A_Recoil(-1.0); }
		GOAT EF 4 A_FaceTarget();
		GOAT G 5 A_GoatAttack();
		GOAT F 3;
		GOAT F 0 A_JumpIf(!CheckMeleeRange()||!target||(target.health<=0),"See");
		Goto Melee2;
	Melee2:
		GOAT Q 4 { A_FaceTarget(); A_Recoil(-1.0); }
		GOAT PQ 4 A_FaceTarget();
		GOAT R 5 A_GoatAttack();
		GOAT Q 3;
		GOAT Q 0 A_JumpIf(!CheckMeleeRange()||!target||(target.health<=0),"See");
		Goto Melee+1;
	Pain:
		GOAT H 0 A_JumpIf(chargetimer>0,"PainRecoil");
		GOAT H 0 { PainChance = 100; }
		GOAT H 10 A_Pain();
		Goto See;
	Recoil:
		GOAT A 0 { PainChance = 0; }
		GOAT A 30;
		GOAT A 1 A_JumpIf(vel.length()<1,1);
		Wait;
		GOAT A 0 { PainChance = 100; }
		Goto See;
	PainRecoil:
		GOAT H 0 { PainChance = 0; }
		GOAT H 10 A_Pain();
		GOAT A 20;
		GOAT A 1 A_JumpIf(vel.length()<1,1);
		Wait;
		GOAT A 0 { PainChance = 100; }
		Goto See;
	Brake:
		GOAT A 0
		{
			sct = 0;
			PainChance = 100;
			bstr = speed*0.8;
			vel.xy = RotateVector((bstr,0),angle);
			A_PlaySound("goat/step",CHAN_7);
			A_PlaySound("goat/brake",CHAN_5);
		}
		GOAT A 1
		{
			if ( !(sct%3) && (vel.length() > 2) )
			{
				Vector3 ofs = (0,0,8);
				ofs.xy = RotateVector((10,0),angle+90);
				Spawn("mkPoof",pos+ofs);
				ofs.xy = RotateVector((10,0),angle-90);
				Spawn("mkPoof",pos+ofs);
			}
			sct++;
			A_FaceTarget(3);
			vel.xy = vel.xy*0.8+RotateVector((bstr,0)*0.2,angle);
			bstr *= 0.95;
			if ( vel.xy.length() <= 1 ) return ResolveState("See");
			return ResolveState(null);
		}
		Wait;
	Death:
		GOAT I 5;
		GOAT J 5 A_Scream();
		GOAT KL 4;
		GOAT M 3 A_QuakeEx(6,6,6,30,0,800,"",QF_RELATIVE|QF_SCALEDOWN,falloff:200);
		GOAT N 3
		{
			A_NoBlocking();
			A_PlaySound("goat/thump",CHAN_7);
		}
		GOAT O 120;
		GOAT O 0
		{
			let s = Spawn("mkSeacatFade",pos);
			s.target = self;
		}
		GOAT O 1 A_FadeOut(0.04);
		Wait;
	}
}

// based on realm667 weapon
Class Casing44 : Actor
{
	int deadtimer;
	double rollvel;

	Default
	{
		Radius 2;
		Height 2;
		+NOBLOCKMAP;
		+ROLLSPRITE;
		+ROLLCENTER;
		+FORCEXYBILLBOARD;
		+MISSILE;
		+MOVEWITHSECTOR;
		+THRUACTORS;
		BounceType "Doom";
		BounceFactor 0.75;
		BounceSound "misc/scase";
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		deadtimer = 0;
		rollvel = FRandom[Junk](20,80)*RandomPick[Junk](-1,1);
	}
	override void Tick()
	{
		Super.Tick();
		if ( InStateSequence(CurState,ResolveState("Death")) )
		{
			deadtimer++;
			if ( deadtimer > 300 ) A_FadeOut(0.1);
			return;
		}
	}
	States
	{
	Spawn:
		WCAS A 1 A_SetRoll(roll+invoker.rollvel);
		Wait;
	Bounce:
		WCAS A 0 { invoker.rollvel = FRandom[Junk](10,30)*RandomPick[Junk](-1,1); }
		Goto Spawn;
	Death:
		WCAS A -1 A_SetRoll(FRandom[Junk](-5,5)+RandomPick[Junk](0,180));
		Stop;
	}
}

Class W44Ammo : Ammo
{
	Default
	{
		Tag ".44 Winchester";
		Inventory.Icon "WAMOA0";
		Inventory.PickupMessage "You got some .44 rounds.";
		Inventory.Amount 4;
		Inventory.MaxAmount 50;
		Ammo.BackpackAmount 20;
		Ammo.BackpackMaxAmount 100;
		Ammo.DropAmount 4;
	}
	States
	{
	Spawn:
		WAMO A -1;
		Stop;
	}
}

Class W44AmmoBox : W44Ammo
{
	Default
	{
		Inventory.PickupMessage "You got a box of .44 rounds.";
		Inventory.Amount 15;
	}
	States
	{
	Spawn:
		WAMO B -1;
		Stop;
	}
}

Class W44Tracer : LineTracer
{
	Actor ignore;
	Array<Actor> hitlist;
	Array<int> headshots;
	Array<double> hitangles;
	Array<double> hitpitches;
	Array<double> hitx;
	Array<double> hity;
	Array<double> hitz;

	override ETraceStatus TraceCallback()
	{
		if ( Results.HitType == TRACE_HitActor )
		{
			if ( Results.HitActor == ignore ) return TRACE_Skip;
			if ( Results.HitActor.bSHOOTABLE )
			{
				hitlist.Push(Results.HitActor);
				headshots.Push(Results.HitPos.z >= (Results.HitActor.pos.z+Results.HitActor.height*0.81));
				hitangles.Push(atan2(Results.HitVector.y,Results.HitVector.x));
				hitpitches.Push(asin(-Results.HitVector.z));
				hitx.Push(Results.HitPos.x);
				hity.Push(Results.HitPos.y);
				hitz.Push(Results.HitPos.z);
			}
			return TRACE_Skip;
		}
		else if ( (Results.HitType == TRACE_HitWall) && (Results.Tier == TIER_Middle) )
		{
			if ( !Results.HitLine.sidedef[1] || (Results.HitLine.Flags&(Line.ML_BlockHitscan|Line.ML_BlockEverything)) )
			{
				hitangles.Push(atan2(Results.HitVector.y,Results.HitVector.x));
				hitpitches.Push(asin(-Results.HitVector.z));
				hitx.Push(Results.HitPos.x);
				hity.Push(Results.HitPos.y);
				hitz.Push(Results.HitPos.z);
				return TRACE_Stop;
			}
			return TRACE_Skip;
		}
		hitangles.Push(atan2(Results.HitVector.y,Results.HitVector.x));
		hitpitches.Push(asin(-Results.HitVector.z));
		hitx.Push(Results.HitPos.x);
		hity.Push(Results.HitPos.y);
		hitz.Push(Results.HitPos.z);
		return TRACE_Stop;
	}
}

Class Model1873 : DoomWeapon
{
	transient W44Tracer t;

	Default
	{
		Tag "Sawed-Off Model 1873";
		Weapon.SelectionOrder 1300;
		Weapon.SlotNumber 3;
		Weapon.AmmoUse 1;
		Weapon.AmmoGive 8;
		Weapon.AmmoType "W44Ammo";
		Weapon.KickBack 200;
		Inventory.PickupMessage "You got the sawed-off Model 1873!";
		+WEAPON.CHEATNOTWEAPON;
	}
	action void A_FireShot()
	{
		let w = Weapon(invoker);
		if ( !w || (w.Ammo1.Amount <= 0) || !w.DepleteAmmo(w.bAltFire,true,1) )
			return;
		A_PlaySound("seacat/rfire",CHAN_WEAPON);
		A_GunFlash();
		Vector3 x, y, z, dir;
		double a, s;
		[x, y, z] = st_Matrix4Lite.GetAxes(BulletSlope(),angle,roll);
		if ( !invoker.t ) invoker.t = new("W44Tracer");
		invoker.t.ignore = self;
		invoker.t.hitlist.Clear();
		invoker.t.headshots.Clear();
		invoker.t.hitangles.Clear();
		invoker.t.hitpitches.Clear();
		invoker.t.hitx.Clear();
		invoker.t.hity.Clear();
		invoker.t.hitz.Clear();
		invoker.t.Trace(Vec2OffsetZ(0,0,player.viewz),CurSector,x,PLAYERMISSILERANGE,0);
		int totaldamage = Random[GunShot](30,40)*3;
		for ( int i=0; i<invoker.t.hitlist.Size(); i++ )
		{
			Vector3 hitdir = (cos(invoker.t.hitangles[i])*cos(invoker.t.hitpitches[i]),sin(invoker.t.hitangles[i])*cos(invoker.t.hitpitches[i]),-sin(invoker.t.hitpitches[i]));
			Vector3 hitpos = (invoker.t.hitx[i],invoker.t.hity[i],invoker.t.hitz[i]);
			int dmg = totaldamage;
			int thrust = 30*dmg;
			Name dmgtype = 'Shot';
			if ( invoker.t.headshots[i] )
			{
				dmg *= 3;
				thrust /= 3;
				dmgtype = 'Headshot';
				totaldamage -= invoker.t.hitlist[i].Health/3;
			}
			else totaldamage -= invoker.t.hitlist[i].Health;
			invoker.t.hitlist[i].DamageMobj(w,self,dmg,dmgtype,DMG_THRUSTLESS);
			if ( !invoker.t.hitlist[i].bDONTTHRUST )
				invoker.t.hitlist[i].vel += hitdir*(thrust/invoker.t.hitlist[i].mass);
			if ( invoker.t.hitlist[i].bNOBLOOD )
			{
				let p = Spawn("BulletPuff",hitpos-hitdir*4);
				p.angle = invoker.t.hitangles[i];
				p.pitch = invoker.t.hitpitches[i];
				p.A_PlaySound("misc/parp",CHAN_7,attenuation:2.0);
				p.A_SprayDecal("BulletChip");
			}
			else
			{
				invoker.t.hitlist[i].TraceBleed(dmg,self);
				invoker.t.hitlist[i].SpawnBlood(hitpos,invoker.t.hitangles[i]+180,dmg);
				invoker.t.hitlist[i].A_PlaySound("misc/bullet",CHAN_7,attenuation:2.0);
			}
			if ( totaldamage <= 0 )
				return;
		}
		if ( invoker.t.Results.HitType == TRACE_HitNone )
			return;
		int i = invoker.t.hitlist.Size();
		Vector3 hitdir = (cos(invoker.t.hitangles[i])*cos(invoker.t.hitpitches[i]),sin(invoker.t.hitangles[i])*cos(invoker.t.hitpitches[i]),-sin(invoker.t.hitpitches[i]));
		Vector3 hitpos = (invoker.t.hitx[i],invoker.t.hity[i],invoker.t.hitz[i]);
		let p = Spawn("BulletPuff",hitpos-hitdir*4);
		p.angle = invoker.t.hitangles[i];
		p.pitch = invoker.t.hitpitches[i];
		p.A_SprayDecal("BulletChip");
		p.A_PlaySound("misc/ric",CHAN_7,attenuation:2.0);
	}
	action void A_Eject()
	{
		Vector3 ofs = Vec2OffsetZ(0,0,player.viewz);
		Vector3 x, y, z;
		[x, y, z] = st_Matrix4Lite.GetAxes(pitch,angle,roll);
		ofs += x*20.-y*15-z*12;
		let c = Spawn("Casing44",ofs);
		c.vel = x*FRandom[Junk](0,2)-y*FRandom[Junk](5,8)+z*FRandom[Junk](3,6);
		c.vel += vel*0.5;
	}
	States
	{
	Spawn:
		MSSI A -1;
		Stop;
	Select:
		MSSG A 1 A_Raise();
		Wait;
	Ready:
		MSSG A 1 A_WeaponReady();
		Wait;
	Fire:
		MSSG A 3;
		MSSG A 0 A_FireShot();
		MSSF AA 1 A_WeaponOffset(0,4,WOF_ADD);
		MSSF AB 1 A_WeaponOffset(0,2,WOF_ADD);
		MSSF BB 1 A_WeaponOffset(0,1,WOF_ADD);
		MSSF AA 1 A_WeaponOffset(0,-3,WOF_ADD);
		MSSG AAAA 1 A_WeaponOffset(0,-2,WOF_ADD);
		MSSG A 3;
		MSSG A 0 A_PlaySound("seacat/rreload",CHAN_5);
		MSSG AA 1 A_WeaponOffset(-6,0,WOF_ADD);
		MSSG BBB 1 A_WeaponOffset(-4,2,WOF_ADD);
		MSSG CCC 1 A_WeaponOffset(-3,3,WOF_ADD);
		MSSG DDD 1 A_WeaponOffset(-2,4,WOF_ADD);
		MSSG EE 1 A_WeaponOffset(-1,6,WOF_ADD);
		MSSG E 3 A_Eject();
		MSSG EE 1 A_WeaponOffset(1,-6,WOF_ADD);
		MSSG DDD 1 A_WeaponOffset(2,-4,WOF_ADD);
		MSSG CCC 1 A_WeaponOffset(3,-3,WOF_ADD);
		MSSG BBB 1 A_WeaponOffset(4,-2,WOF_ADD);
		MSSG AA 1 A_WeaponOffset(6,0,WOF_ADD);
		Goto Ready;
	Flash:
		TNT1 A 4 A_Light1();
		TNT1 A 4 A_Light2();
		Goto LightDone;
	Deselect:
		MSSG A 1 A_Lower();
		Wait;
	}
}

Class mkSkySphere : Actor
{
	Default
	{
		Radius 32;
		Height 32;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
	States
	{
	Spawn:
		MODL A -1 BRIGHT;
		Stop;
	}
}

// Auto-kills players and monsters that fall off the map
// Ignores god mode and other cheats, so be careful
// The way this works additionally screws with the resurrect cheat, but
// considering how many things that cheat can break already, who cares
Class mkSecret05FallEffect : Thinker
{
	Actor victim;
	int tcnt;

	static void AttachTo( Actor victim )
	{
		let t = ThinkerIterator.Create("mkSecret05FallEffect",STAT_USER);
		mkSecret05FallEffect e;
		while ( e = mkSecret05FallEffect(t.Next()) )
		{
			if ( e.victim == victim )
				return;
		}
		if ( !victim.player && (victim.Health <= 0) && (victim.tics == -1) )
		{
			victim.A_FadeOut();
			return;
		}
		e = new("mkSecret05FallEffect");
		e.ChangeStatNum(STAT_USER);
		e.victim = victim;
		if ( victim.Health <= 0 ) return;
		if ( victim.player ) victim.A_PlayerScream();
		else victim.A_Scream();
	}

	override void Tick()
	{
		Super.Tick();
		if ( !victim || (victim.pos.z > -240) )
		{
			Destroy();
			return;
		}
		if ( victim.Health <= 0 )
		{
			if ( !victim.player ) Destroy();
			return;
		}
		victim.A_SetBlend("70 20 A0",min(1,tcnt/35.),35);
		tcnt++;
		if ( tcnt >= 60 )
		{
			victim.DamageMobj(null,null,int.max,'Void',DMG_FORCED|DMG_THRUSTLESS);
			if ( victim.player )
			{
				// gay seacat babby jail
				victim.SetOrigin((0,-1664,0),false);
				victim.vel *= 0;
				victim.player.vel *= 0;
			}
		}
	}
}

Class mkSecret05FallHandler : Actor
{
	transient ThinkerIterator ti;

	override void Tick()
	{
		Super.Tick();
		if ( !ti ) ti = ThinkerIterator.Create("Actor");
		else ti.Reinit();
		Actor a;
		while ( a = Actor(ti.Next()) )
		{
			if ( !a.player && !a.bISMONSTER ) continue;
			if ( a.pos.z < -240 )
				mkSecret05FallEffect.AttachTo(a);
		}
	}

	Default
	{
		//$Title SECRET05 Fall Handler
		//$Category Marisa Kirisame
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
}

Class mkSecret05OutsideWind : Actor
{
	double vol, gvol;

	override void Tick()
	{
		Super.Tick();
		let s = players[consoleplayer].mo.CurSector;
		if ( (s.GetTexture(0) == skyflatnum) || (s.GetTexture(1) == skyflatnum) )
			vol = min(1,vol+0.01);
		else
			vol = max(0,vol-0.01);
		A_SoundVolume(CHAN_5,vol);
		A_SoundVolume(CHAN_6,(1-vol)*0.5*gvol);
		if ( args[0] )
			gvol = max(0,gvol-0.04);
		else
			gvol = min(1,gvol+0.04);
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		gvol = 1;
		A_PlaySound("seacat/flangestorm",CHAN_5,0.001,true,ATTN_NONE);
		A_PlaySound("seacat/wind",CHAN_6,0.001,true,ATTN_NONE);
	}

	Default
	{
		//$Title SECRET05 Outside Wind
		//$Category Marisa Kirisame
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
}

Class mkSecret05ProximityTrigger : Actor
{
	transient ThinkerIterator ti;

	override void Tick()
	{
		Super.Tick();
		if ( !ti ) ti = ThinkerIterator.Create("PlayerPawn");
		else ti.Reinit();
		Actor a;
		while ( a = Actor(ti.Next()) )
		{
			if ( (Distance2D(a) > score) || !CheckSight(a) ) continue;
			level.ExecuteSpecial(special,a,null,false,args[0],args[1],args[2],args[3],args[4]);
			Destroy();
			return;
		}
	}

	Default
	{
		//$Title SECRET05 Proximity Trigger
		//$Category Marisa Kirisame
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DONTSPLASH;
	}
}

// Big thing
Class mkSecret05GoatInvasion : Actor
{
	Struct Wave
	{
		// wave counts
		int lessergoats, goats;
		int shellboxes, shells;
		int medikits, stimpacks;
		// maximum active goat budget
		int goatbudget;
		// spawnpoints
		int goattid, ammotid, healthtid;
		// world stuffs
		int useline;	// line to use for activating this stage
		int gate;	// gate that opens for this stage, then closes at start
		int blockline;	// line that blocks while the gate closes on starting this stage
		// completed
		bool completed;
	};

	Wave waves[11];
	int curwave;
	Array<Actor> goatspawns, ammospawns, healthspawns;
	Array<Actor> goats, ammos, healths;

	int CountHealth()
	{
		let g = GetDefaultByType("mkGoatServant");
		let lg = GetDefaultByType("mkLesserGoatServant");
		// count up totals
		int th = 0;
		for ( int i=0; i<11; i++ )
		{
			th += waves[i].goats*g.Health;
			th += waves[i].lessergoats*lg.Health;
		}
		for ( int i=0; i<goats.Size(); i++ )
			th += max(0,goats[i].Health);
		return th;
	}

	override void Tick()
	{
		// auto cleanup, needs to be called before Actor Tick
		for ( int i=0; i<goats.Size(); i++ )
		{
			if ( goats[i] && (goats[i].Health > 0) ) continue;
			goats.Delete(i--);
		}
		for ( int i=0; i<ammos.Size(); i++ )
		{
			if ( ammos[i] ) continue;
			ammos.Delete(i--);
		}
		for ( int i=0; i<healths.Size(); i++ )
		{
			if ( healths[i] ) continue;
			healths.Delete(i--);
		}
		Super.Tick();
		// update health for boss bar
		Health = CountHealth();
	}

	double AngleToRandomPlayer( Actor a )
	{
		Array<Actor> aplayers;
		for ( int i=0; i<MAXPLAYERS; i++ )
			if ( playeringame[i] && players[i].mo )
				aplayers.Push(players[i].mo);
		if ( aplayers.Size() == 0 )
			ThrowAbortException("How in the hell are there no players?");
		return a.AngleTo(aplayers[Random[Seacat](0,aplayers.Size()-1)]);
	}

	void Initialize()
	{
		// fill out waves
		// 1
		waves[0].lessergoats = 10;
		waves[0].goatbudget = 2;
		waves[0].shells = 8;
		waves[0].stimpacks = 4;
		waves[0].goattid = 201;
		waves[0].ammotid = 301;
		waves[0].healthtid = 401;
		// 2
		waves[1].lessergoats = 15;
		waves[1].goatbudget = 4;
		waves[1].shells = 8;
		waves[1].stimpacks = 6;
		waves[1].goattid = 202;
		waves[1].ammotid = 302;
		waves[1].healthtid = 402;
		waves[1].useline = 4;
		waves[1].blockline = 3;
		waves[1].gate = 3;
		// 3
		waves[2].lessergoats = 20;
		waves[2].goats = 5;
		waves[2].goatbudget = 5;
		waves[2].shellboxes = 3;
		waves[2].shells = 5;
		waves[2].medikits = 1;
		waves[2].stimpacks = 6;
		waves[2].goattid = 203;
		waves[2].ammotid = 303;
		waves[2].healthtid = 403;
		waves[2].useline = 6;
		waves[2].blockline = 5;
		waves[2].gate = 4;
		// 4
		waves[3].lessergoats = 20;
		waves[3].goats = 5;
		waves[3].goatbudget = 5;
		waves[3].shellboxes = 4;
		waves[3].shells = 6;
		waves[3].stimpacks = 8;
		waves[3].goattid = 204;
		waves[3].ammotid = 304;
		waves[3].healthtid = 404;
		waves[3].useline = 8;
		waves[3].blockline = 7;
		waves[3].gate = 5;
		// 5
		waves[4].lessergoats = 25;
		waves[4].goats = 10;
		waves[4].goatbudget = 8;
		waves[4].shells = 6;
		waves[4].stimpacks = 8;
		waves[4].goattid = 205;
		waves[4].ammotid = 305;
		waves[4].healthtid = 405;
		waves[4].useline = 10;
		waves[4].blockline = 9;
		waves[4].gate = 6;
		// 6
		waves[5].lessergoats = 30;
		waves[5].goats = 10;
		waves[5].goatbudget = 8;
		waves[5].shellboxes = 4;
		waves[5].shells = 6;
		waves[5].medikits = 3;
		waves[5].stimpacks = 8;
		waves[5].goattid = 206;
		waves[5].ammotid = 306;
		waves[5].healthtid = 406;
		waves[5].useline = 12;
		waves[5].blockline = 11;
		waves[5].gate = 7;
		// 7
		waves[6].lessergoats = 20;
		waves[4].goats = 5;
		waves[6].goatbudget = 10;
		waves[6].shellboxes = 4;
		waves[6].stimpacks = 10;
		waves[6].goattid = 205;
		waves[6].ammotid = 305;
		waves[6].healthtid = 405;
		waves[6].useline = 11;
		waves[6].blockline = 12;
		waves[6].gate = 7;
		// 8
		waves[7].lessergoats = 25;
		waves[7].goats = 10;
		waves[7].goatbudget = 6;
		waves[7].shellboxes = 3;
		waves[7].shells = 6;
		waves[7].stimpacks = 8;
		waves[7].goattid = 207;
		waves[7].ammotid = 307;
		waves[7].healthtid = 407;
		waves[7].useline = 14;
		waves[7].blockline = 13;
		waves[7].gate = 8;
		// 9
		waves[8].lessergoats = 20;
		waves[8].goats = 20;
		waves[8].goatbudget = 6;
		waves[8].shellboxes = 3;
		waves[8].medikits = 4;
		waves[8].goattid = 208;
		waves[8].ammotid = 308;
		waves[8].healthtid = 408;
		waves[8].useline = 16;
		waves[8].blockline = 15;
		waves[8].gate = 9;
		// 10
		waves[9].lessergoats = 30;
		waves[9].goatbudget = 6;
		waves[9].shellboxes = 3;
		waves[9].stimpacks = 10;
		waves[9].goattid = 209;
		waves[9].ammotid = 309;
		waves[9].healthtid = 409;
		waves[9].useline = 18;
		waves[9].blockline = 17;
		waves[9].gate = 10;
		// 11
		waves[10].goats = 30;
		waves[10].goatbudget = 16;
		waves[10].shellboxes = 6;
		waves[10].stimpacks = 10;
		waves[10].goattid = 201;
		waves[10].ammotid = 301;
		waves[10].healthtid = 401;
		waves[10].useline = 2;
		waves[10].blockline = 1;
		waves[10].gate = 11;
		// register for boss health bar
		let hnd = SpooktoberHandler(EventHandler.Find("SpooktoberHandler"));
		hnd.bossenemy = self;
	}

	void StartWave( int wavenum )
	{
		curwave = wavenum;
		// clear current spawn spots
		goatspawns.Clear();
		ammospawns.Clear();
		healthspawns.Clear();
		// these can be removed now
		for ( int i=0; i<ammos.Size(); i++ )
			ammos[i].Destroy();
		for ( int i=0; i<healths.Size(); i++ )
			healths[i].Destroy();
		goats.Clear();
		ammos.Clear();
		healths.Clear();
		// fetch new spots
		ActorIterator ai;
		Actor a;
		ai = ActorIterator.Create(waves[curwave].goattid);
		while ( a = ai.Next() ) goatspawns.Push(a);
		ai = ActorIterator.Create(waves[curwave].ammotid);
		while ( a = ai.Next() ) ammospawns.Push(a);
		ai = ActorIterator.Create(waves[curwave].healthtid);
		while ( a = ai.Next() ) healthspawns.Push(a);
	}

	Actor PickGoatSpot()
	{
		Array<Actor> available;
		for ( int i=0; i<goatspawns.Size(); i++ )
		{
			// is it being blocked?
			bool blocked = false;
			for ( int j=0; j<goats.Size(); j++ )
			{
				if ( goats[j].Distance2D(goatspawns[i]) > 120 )
					continue;
				blocked = true;
				break;
			}
			for ( int j=0; j<MAXPLAYERS; j++ )
			{
				if ( !playeringame[j] || players[j].mo.Distance2D(goatspawns[i]) > 240 )
					continue;
				blocked = true;
				break;
			}
			// can it be seen
			bool seen = false;
			for ( int j=0; j<MAXPLAYERS; j++ )
			{
				if ( !playeringame[j] || !players[j].mo.IsVisible(goatspawns[i],true) )
					continue;
				seen = true;
				break;
			}
			if ( !blocked && seen )
				available.Push(goatspawns[i]);
		}
		if ( available.Size() <= 0 )
			return null;
		return available[Random[Seacat](0,available.Size()-1)];
	}

	Actor PickAmmoSpot()
	{
		Array<Actor> available;
		for ( int i=0; i<ammospawns.Size(); i++ )
		{
			// is it being used?
			bool used = false;
			for ( int j=0; j<ammos.Size(); j++ )
			{
				if ( ammos[j].Distance2D(ammospawns[i]) > 16 )
					continue;
				used = true;
				break;
			}
			// can it be seen
			bool seen = false;
			for ( int j=0; j<MAXPLAYERS; j++ )
			{
				if ( !playeringame[j] || !players[j].mo.IsVisible(ammospawns[i],true) )
					continue;
				seen = true;
				break;
			}
			if ( !used && seen )
				available.Push(ammospawns[i]);
		}
		if ( available.Size() <= 0 )
			return null;
		return available[Random[Seacat](0,available.Size()-1)];
	}

	Actor PickHealthSpot()
	{
		Array<Actor> available;
		for ( int i=0; i<healthspawns.Size(); i++ )
		{
			// is it being used?
			bool used = false;
			for ( int j=0; j<healths.Size(); j++ )
			{
				if ( healths[j].Distance2D(healthspawns[i]) > 16 )
					continue;
				used = true;
				break;
			}
			// without love, it cannot be seen
			bool seen = false;
			for ( int j=0; j<MAXPLAYERS; j++ )
			{
				if ( !playeringame[j] || !players[j].mo.IsVisible(healthspawns[i],true) )
					continue;
				seen = true;
				break;
			}
			if ( !used && seen )
				available.Push(healthspawns[i]);
		}
		if ( available.Size() <= 0 )
			return null;
		return available[Random[Seacat](0,available.Size()-1)];
	}

	bool SpawnGoats()
	{
		if ( waves[curwave].goats+waves[curwave].lessergoats <= 0 )
		{
			if ( goats.Size() == 0 )
				waves[curwave].completed = true;
			return false;
		}
		// check budget
		int curbudget = 0;
		for ( int i=0; i<goats.Size(); i++ )
		{
			if ( goats[i] is 'mkGoatServant' ) curbudget += 4;
			else curbudget += 1;
		}
		if ( curbudget >= waves[curwave].goatbudget ) return false;
		bool spawnbig = false;
		if ( waves[curwave].goats > 0 )
			spawnbig = (waves[curwave].lessergoats>0)?(!Random[Seacat](0,3)):true;
		let s = PickGoatSpot();
		if ( !s ) return false;
		Actor goat;
		if ( spawnbig )
		{
			goat = Spawn("mkGoatServant",s.pos);
			waves[curwave].goats--;
		}
		else
		{
			goat = Spawn("mkLesserGoatServant",s.pos);
			waves[curwave].lessergoats--;
		}
		goat.angle = AngleToRandomPlayer(goat);
		goat.master = self;
		goats.Push(goat);
		return true;
	}

	bool SpawnAmmo()
	{
		if ( waves[curwave].shellboxes+waves[curwave].shells <= 0 )
			return false;
		bool spawnbig = false;
		if ( waves[curwave].shellboxes > 0 )
			spawnbig = waves[curwave].shells>0?(!Random[Seacat](0,3)):true;
		let s = PickAmmoSpot();
		if ( !s ) return false;
		Actor amo;
		Spawn("ItemFog",s.pos);
		if ( spawnbig )
		{
			amo = Spawn("W44AmmoBox",s.pos);
			waves[curwave].shellboxes--;
		}
		else
		{
			amo = Spawn("W44Ammo",s.pos);
			waves[curwave].shells--;
		}
		amo.angle = s.angle;
		amo.A_PlaySound("misc/spawn",CHAN_VOICE);
		ammos.Push(amo);
		return true;
	}

	bool SpawnHealing()
	{
		if ( waves[curwave].medikits+waves[curwave].stimpacks <= 0 )
			return false;
		bool spawnbig = false;
		if ( waves[curwave].medikits > 0 )
			spawnbig = waves[curwave].stimpacks>0?(!Random[Seacat](0,3)):true;
		let s = PickHealthSpot();
		if ( !s ) return false;
		Actor heal;
		Spawn("ItemFog",s.pos);
		if ( spawnbig )
		{
			heal = Spawn("Medikit",s.pos,ALLOW_REPLACE);
			waves[curwave].medikits--;
		}
		else
		{
			heal = Spawn("Stimpack",s.pos,ALLOW_REPLACE);
			waves[curwave].stimpacks--;
		}
		heal.angle = s.angle;
		heal.A_PlaySound("misc/spawn",CHAN_VOICE);
		healths.Push(heal);
		return true;
	}

	void WaveThink()
	{
		if ( waves[curwave].completed ) return;
		// spawn stuff
		int n = Random[Seacat](1,3);
		for ( int i=0; i<n; i++ )
		{
			if ( !SpawnGoats() )
				break;
		}
		for ( int i=0; i<2; i++ )
		{
			if ( Random[Seacat](0,2) || !SpawnHealing() )
				SpawnAmmo();
		}
		// open the gates once we've run out of goats for this wave
		// at the last wave, do the exit special instead
		if ( !waves[curwave].completed ) return;
		if ( curwave < 10 )
			ACS_Execute(201,0,waves[curwave+1].useline,waves[curwave+1].gate,waves[curwave+1].blockline);
		else
		{
			ACS_Execute(5,0);
			A_Die();
		}
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		Initialize();
	}

	override void Activate( Actor activator )
	{
		// wave advancing
		SetState(CurState+1);
	}

	Default
	{
		Tag "\cmAll Of The Goats\c-";
		+NOGRAVITY;
		+NOBLOCKMAP;
	}
	States
	{
	Spawn:
		TNT1 A -1;	// waiting
		Stop;
		TNT1 A 150;	// delay for the player(s) to brace themselves
	Wave1:
		TNT1 A 0 StartWave(0);
		TNT1 A 120 WaveThink();
		Wait;
	Wave2:
		TNT1 A 0 StartWave(1);
		TNT1 A 110 WaveThink();
		Wait;
	Wave3:
		TNT1 A 0 StartWave(2);
		TNT1 A 100 WaveThink();
		Wait;
	Wave4:
		TNT1 A 0 StartWave(3);
		TNT1 A 90 WaveThink();
		Wait;
	Wave5:
		TNT1 A 0 StartWave(4);
		TNT1 A 80 WaveThink();
		Wait;
	Wave6:
		TNT1 A 0 StartWave(5);
		TNT1 A 70 WaveThink();
		Wait;
	Wave7:
		TNT1 A 0 StartWave(6);
		TNT1 A 60 WaveThink();
		Wait;
	Wave8:
		TNT1 A 0 StartWave(7);
		TNT1 A 50 WaveThink();
		Wait;
	Wave9:
		TNT1 A 0 StartWave(8);
		TNT1 A 40 WaveThink();
		Wait;
	Wave10:
		TNT1 A 0 StartWave(9);
		TNT1 A 30 WaveThink();
		Wait;
	Wave11:
		TNT1 A 0 StartWave(10);
		TNT1 A 20 WaveThink();
		Wait;
	Death:
		TNT1 A 200;
		Stop;
	}
}
