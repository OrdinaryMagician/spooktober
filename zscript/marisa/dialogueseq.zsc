// Dialogue sequences base class
Class mkDialogueSequence : HUDMessageBase
{
	PlayerInfo p;
	int seqnum, curstate, curdelay, delaycnt, charcnt, col, tspeed, fx, rss;
	double dimalpha, vvol;
	bool bStarted, bInText;
	transient BrokenLines lines;
	String savedtext;
	String header, voice;
	transient Font tfont;

	enum ETextEffect
	{
		TE_None,
		TE_Shiver
	};

	private int GetRandom()
	{
		return (rss = (rss<<1)*35447+(rss/87));
	}

	private double RandomShiver()
	{
		int sd = GetRandom();
		return ((abs(sd)%11)-5)*0.1;
	}

	mkDialogueSequence Init( int seqnum, PlayerInfo p )
	{
		self.seqnum = seqnum;
		self.p = p;
		self.voice = "misc/voice";
		self.col = Font.CR_WHITE;
		self.tspeed = 1;
		self.vvol = 0.5;
		return self;
	}

	private void DrawShiver( String part, Vector2 pos )
	{
		for ( int i=0; i<part.length(); i++ )
		{
			// TODO process color escapes
			Screen.DrawChar(tfont,col,pos.x+RandomShiver(),pos.y+RandomShiver(),part.CharCodeAt(i),DTA_Bottom320x200,true,DTA_Alpha,dimalpha);
			pos.x += tfont.GetCharWidth(part.CharCodeAt(i));
		}
	}

	private void DrawText()
	{
		if ( !lines ) StartText(savedtext,true);
		if ( !tfont ) tfont = Font.GetFont('STAT_LWR');
		int cur = charcnt;
		Vector2 pos = (15,164);
		for ( int i=0; i<lines.Count(); i++ )
		{
			if ( cur <= 0 ) break;
			String part = lines.StringAt(i).Left(cur);
			if ( fx == TE_Shiver ) DrawShiver(part,pos);
			else Screen.DrawText(tfont,col,pos.x,pos.y,part,DTA_Bottom320x200,true,DTA_Alpha,dimalpha);
			pos.y += tfont.GetHeight()+1;
			cur -= lines.StringAt(i).Length();
		}
	}

	protected void SetHeader( String nhead )
	{
		if ( nhead.CharAt(0) == "$" ) header = StringTable.Localize(nhead);
		else header = nhead;
	}

	protected void SetVoice( String nvoice )
	{
		voice = nvoice;
	}

	protected void SetTextEffect( int nfx )
	{
		fx = nfx;
	}

	protected void SetTextColor( int ncol )
	{
		col = ncol;
	}

	protected void SetTextSpeed( int nspeed )
	{
		tspeed = nspeed;
	}

	protected void SetVoiceVolume( double nvol )
	{
		vvol = nvol;
	}

	protected void EndSeq( int next )
	{
		EventHandler.SendNetworkEvent("dialogue_setnext",next);
		EventHandler.SendNetworkEvent("dialogue_special");
		seqnum = 0;
	}

	protected void StartText( string cont, bool rebuild = false )
	{
		String loc = cont;
		savedtext = cont;
		if ( cont.CharAt(0) == "$" ) loc = StringTable.Localize(cont);
		// replace player name
		String pname = p.GetUserName();
		if ( pname ~== "Player" ) pname = StringTable.Localize("$DEFPNAME");
		else pname = "\cf"..pname.."\c-";
		loc.Replace("%pn",pname);
		if ( !tfont ) tfont = Font.GetFont('STAT_LWR');
		lines = tfont.BreakLines(loc,290);
		// these two mustn't be reset on BrokenLines rebuilding
		if ( rebuild ) return;
		charcnt = 0;
		bInText = true;
	}

	protected virtual void DialogueSeq( int state )
	{
		// default
		EndSeq(0);
	}

	private int TotalLength()
	{
		if ( !lines ) StartText(savedtext,true);
		int len = 0;
		for ( int i=0; i<lines.Count(); i++ )
			len += lines.StringAt(i).Length();
		return len;
	}

	private String GetChar( int pos )
	{
		if ( !lines ) StartText(savedtext,true);
		int cur = pos;
		for ( int i=0; i<lines.Count(); i++ )
		{
			int len = lines.StringAt(i).Length();
			if ( cur < len )
				return lines.StringAt(i).CharAt(cur);
			cur -= len;
		}
		return "";
	}

	private void AdvanceText( bool bSkip )
	{
		String whitespace = " \t\n";
		String punctuation = ",;:.?!";
		charcnt++;
		String ch = GetChar(charcnt);
		// skip over color escapes
		if ( ch == "\c" )
		{
			ch = GetChar(++charcnt);
			if ( ch == "[" ) while ( (ch = GetChar(++charcnt)) != "]" );
			charcnt++;
		}
		if ( charcnt >= TotalLength() )
		{
			if ( !bSkip ) return;
			bInText = false;
			curstate++;
			curdelay = 5;
			return;
		}
		// play sound on non-whitespace
		if ( (whitespace.IndexOf(ch) == -1) && (p == players[consoleplayer]) )
			S_Sound(voice,CHAN_VOICE|CHAN_UI,vvol,ATTN_NONE);
		if ( bSkip )
		{
			charcnt = TotalLength();
			curdelay = 5;
		}
		else
		{
			curdelay = tspeed;
			// increase delay on stops
			if ( punctuation.IndexOf(ch) != -1 )
				curdelay = curdelay*2+2;
		}
	}

	override bool Tick()
	{
		bool bSkip = !!(p.cmd.buttons&BT_USE);
		rss = Random[DialogueSeq]();
		if ( !bStarted )
		{
			bStarted = true;
			EventHandler.SendNetworkEvent("dialogue_start");
		}
		// here comes the spaghetti code!
		// fade in textbox
		if ( seqnum && (dimalpha < 1.0) )
		{
			dimalpha = min(1.0,dimalpha+0.1);
			return false;
		}
		if ( delaycnt < curdelay )
		{
			delaycnt++;
			return false;
		}
		curdelay = 0;
		delaycnt = 0;
		if ( bInText )
		{
			AdvanceText(bSkip);
			return false;
		}
		if ( seqnum )
		{
			DialogueSeq(curstate);
			return false;
		}
		// fade out textbox
		if ( dimalpha > 0.0 )
		{
			dimalpha = max(0.0,dimalpha-0.1);
			return false;
		}
		EventHandler.SendNetworkEvent("dialogue_end");
		return true;
	}

	override void Draw( int bottom, int visibility )
	{
		if ( p != players[consoleplayer] ) return;
		// draw textbox area
		Vector2 pos, sz;
		[pos, sz] = Screen.VirtualToRealCoords((10,160),(300,30),(320,200),true);
		Screen.Dim("Black",dimalpha*0.75,int(pos.x),int(pos.y),int(sz.x),int(sz.y));
		if ( !tfont ) tfont = Font.GetFont('STAT_LWR');
		// draw header (if any)
		if ( header )
		{
			int ln = tfont.StringWidth(header);
			[pos, sz] = Screen.VirtualToRealCoords((12,145),(ln+6,12),(320,200),true);
			Screen.Dim("Black",dimalpha*0.75,int(pos.x),int(pos.y),int(sz.x),int(sz.y));
			Screen.DrawText(tfont,Font.CR_RED,15,148,header,DTA_Bottom320x200,true,DTA_Alpha,dimalpha);
		}
		// draw text, if any
		if ( charcnt > 0 )
		{
			DrawText();
			// draw blinking "next" marker
			if ( (gametic%16 < 8) && (charcnt > TotalLength()) )
				Screen.DrawText(tfont,Font.CR_RED,300,180,">",DTA_Bottom320x200,true,DTA_Alpha,dimalpha);
		}
	}
}

Class mkSmoothLookTo : Thinker
{
	Actor target;
	double angle, pitch, speed;

	static void LookTowards( Actor target, double angle, double pitch, double speed )
	{
		let slt = new("mkSmoothLookTo");
		slt.ChangeStatNum(STAT_USER);
		slt.target = target;
		slt.angle = angle;
		slt.pitch = pitch;
		slt.speed = speed;
	}

	static void LookTowardsTid( Actor target, int ttid, double speed )
	{
		let slt = new("mkSmoothLookTo");
		slt.ChangeStatNum(STAT_USER);
		slt.target = target;
		Actor t = ActorIterator.Create(ttid).Next();
		slt.angle = target.AngleTo(t);
		slt.pitch = mkDialogueHandler.FaceToFace(target,t);
		slt.speed = speed;
	}

	override void Tick()
	{
		Super.Tick();
		double iangle, ipitch;
		iangle = Actor.DeltaAngle(target.angle,angle);
		ipitch = Actor.DeltaAngle(target.pitch,pitch);
		iangle = Clamp(iangle,-speed,speed);
		ipitch = Clamp(ipitch,-speed,speed);
		target.A_SetAngle(target.angle+iangle,SPF_INTERPOLATE);
		target.A_SetPitch(target.pitch+ipitch,SPF_INTERPOLATE);
		if ( (abs(iangle) < double.epsilon) && (abs(ipitch) < double.epsilon) )
			Destroy();
	}
}

// Main handler for all interactive dialogues with the monks
Class mkDialogueHandler : EventHandler
{
	transient int seqtime, seqnum;
	Actor speaker, speakee;
	PlayerInfo starter;
	bool orientspeaker, orientspeakee;
	double oldang, oldpt;

	// gets the pitch needed for one actor to look at another in the face
	static double FaceToFace( Actor a, Actor b )
	{
		Vector3 otherpos = level.Vec3Diff(b.Vec3Offset(0,0,b.height),a.Vec3Offset(0,0,a.height));
		double dist = otherpos.length();
		if ( dist > 0 ) return asin(otherpos.z/dist);
		return 0;
	}

	override void PostUiTick()
	{
		if ( !seqnum || (seqtime < gametic) ) return;
		String sname = String.Format("mkDialogueSequence%d",seqnum);
		Class sclass = sname;
		if ( !sclass )
		{
			Console.Printf("Unknown dialogue sequence %s!",sname);
			return;
		}
		let s = mkDialogueSequence(new(sclass)).Init(seqnum,starter);
		StatusBar.AttachMessage(s,0,BaseStatusBar.HUDMSGLayer_OverHUD);
	}

	override void NetworkProcess( ConsoleEvent e )
	{
		if ( e.IsManual ) return;
		if ( e.Name ~== "dialogue_start" )
		{
			// face each other
			if ( orientspeaker )
			{
				oldang = speaker.angle;
				oldpt = speaker.pitch;
				mkSmoothLookTo.LookTowards(speaker,speaker.AngleTo(speakee),FaceToFace(speaker,speakee),12.0);
			}
			if ( orientspeakee )
				mkSmoothLookTo.LookTowards(speakee,speakee.AngleTo(speaker),FaceToFace(speakee,speaker),3.0);
			speakee.vel *= 0;	// stap
			starter.vel *= 0;	// STAHP
			starter.cheats |= CF_TOTALLYFROZEN; // freeze!
		}
		else if ( e.Name ~== "dialogue_end" )
		{
			// thaw player and return camera
			starter.cheats &= ~CF_TOTALLYFROZEN;
			starter.camera = speakee;
			if ( orientspeaker )
				mkSmoothLookTo.LookTowards(speaker,oldang,oldpt,12.0);
			seqnum = 0;
		}
		else if ( e.Name ~== "dialogue_setcam" )
		{
			if ( e.Args[0] <= 0 ) starter.camera = speakee;
			let i = ActorIterator.Create(e.Args[0]);
			Actor c = i.Next();
			if ( c ) starter.camera = c;
		}
		else if ( e.Name ~== "dialogue_special" )
		{
			// execute speaker's special (if any)
			level.ExecuteSpecial(speaker.special,speakee,null,false,speaker.args[0],speaker.args[1],speaker.args[2],speaker.args[3],speaker.args[4]);
		}
		else if ( e.Name ~== "dialogue_setnext" )
		{
			// set the next dialogue index
			speaker.score = e.Args[0];
		}
		else if ( e.Name ~== "talkedtofirstmonk" )
			Cvar.GetCVar('talkedtofirstmonk').SetBool(true);
		else if ( e.Name ~== "movetobasement" )
			level.ExecuteSpecial(80,null,null,false,202);
		else if ( e.Name ~== "dispelbosspainting" )
			level.ExecuteSpecial(80,null,null,false,203);
		else if ( e.Name ~== "activateboss" )
			level.ExecuteSpecial(80,null,null,false,13);
		else if ( e.Name ~== "activategoats" )
			level.ExecuteSpecial(80,null,null,false,4);
		else if ( e.Name ~== "setspeakerframe" )
			speaker.frame = e.Args[0];
		else if ( e.Name ~== "giveshotty" )
		{
			speakee.GiveInventory("Fist",1);
			speakee.GiveInventory("Model1873",1);
			speakee.A_PlaySound("seacat/rreload",CHAN_WEAPON);
		}
		else if ( e.Name ~== "secret05exit" )
			level.ExecuteSpecial(80,null,null,false,2);
		else if ( e.Name ~== "reggiedropcan" )
			speaker.SetStateLabel("DropCan");
		else if ( e.Name ~== "reggiemorph" )
			speaker.SetStateLabel("Morph");
		else if ( e.Name ~== "reggieend" )
			level.ExecuteSpecial(80,speakee,null,false,-Int('MapFadeOut'));
	}

	static void StartDialogueSequence( Actor speaker, Actor speakee, int seqnum, bool bOrientSpeaker = true, bool bOrientSpeakee = true )
	{
		if ( !speakee.player ) return;	// non-players can't activate these
		let dh = mkDialogueHandler(EventHandler.Find("mkDialogueHandler"));
		if ( !dh ) ThrowAbortException("Dialogue Handler not found!");
		if ( dh.seqnum ) return;	// only one at a time
		dh.seqtime = gametic;
		dh.seqnum = seqnum;
		dh.speaker = speaker;
		dh.speakee = speakee;
		dh.starter = speakee.player;
		dh.orientspeaker = bOrientSpeaker;
		dh.orientspeakee = bOrientSpeakee;
	}
}
