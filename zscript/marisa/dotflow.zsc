// replacement player class for this map
Class Sabitsuki : PlayerPawn
{
	Default
	{
		Speed 1;
		Scale 2;
		Health 100;
		Radius 16;
		Height 56;
		Mass 100;
		Player.SoundClass "sabitsuki";
		Player.DisplayName "Sabitsuki";
		Player.ViewHeight 36;
		Player.ViewBob 0.25;
		Player.ForwardMove 0.8, 0.4;
		Player.SideMove 0.8, 0.4;
		+NOSKIN;
		+NOMENU;
	}
	override void MovePlayer()
	{
		Super.MovePlayer();
		if ( bNoGravity || !player.onground || (waterlevel >= 3) )
			return;
		// decelerate quickly when not moving
		int fm = player.cmd.forwardmove;
		int sm = player.cmd.sidemove;
		if ( !fm && !sm )
		{
			vel.xy *= 0.8;
			player.vel *= 0.8;
			// stop running animation
			if ( InStateSequence(CurState,FindState("See")) )
				PlayIdle();
		}
	}
	States
	{
	Spawn:
		SABI B -1;
		Stop;
	See:
		SABI BABC 4;
		Loop;
	Death:
		SABI DEFGHIJK 4;
		SABI L 12;
		SABI M 6 A_NoBlocking();
		SABI N 4;
		SABI O -1;
		Stop;
	}
}

Class CommonKaibutsu : Actor
{
	int sc, st, wc;
	Default
	{
		//$Title Kaibutsu
		//$Category Marisa Kirisame/dotFlow
		//$Sprite KAI1B1
		Radius 16;
		Height 56;
		Scale 2;
		Speed 10;
		Species "Kaibutsu";
		MONSTER;
		-COUNTKILL;
		+NODAMAGE;
		+SPRITEANGLE;
		+SLIDESONWALLS;
	}
	void A_SetSkin()
	{
		int dec = Random[Kaibutsu](0,2);
		if ( score ) dec = score-1;
		if ( dec == 1 ) sprite = GetSpriteIndex('KAI2');
		else if ( dec == 2 ) sprite = GetSpriteIndex('KAI3');
		else sprite = GetSpriteIndex('KAI1');
	}
	override void Tick()
	{
		Super.Tick();
		double angdiff = deltaangle(AngleTo(players[consoleplayer].camera),angle);
		if ( abs(angdiff) <= 45 ) spriteangle = 180;
		else if ( abs(angdiff) >= 135 ) spriteangle = 0;
		else if ( angdiff > 45 ) spriteangle = 90;
		else if ( angdiff < -45 ) spriteangle = 270;
	}
	bool CheckDirectMove()
	{
		// check if we can move towards target without bumping into anything
		Vector3 oldpos = pos;
		double angdest = AngleTo(target);
		Vector2 dir = (cos(angdest),sin(angdest))*speed;
		for ( int i=0; i<4; i++ )
		{
			if ( TryMove(Vec2Offset(dir.x,dir.y),32) )
				continue;
			if ( BlockingMobj == target )
				break;
			SetOrigin(oldpos,false);
			return false;
		}
		SetOrigin(oldpos,false);
		return true;
	}
	void A_KaibutsuBite()
	{
		if ( !CheckMeleeRange() )
			return;
		A_FaceTarget();
		A_PlaySound("imp/melee",CHAN_WEAPON);
		int dmg = Random[Kaibutsu](3,5);
		int ndmg = target.DamageMobj(self,self,dmg,'Melee',DMG_THRUSTLESS);
		target.TraceBleed((ndmg>0)?ndmg:dmg,self);
	}
	void A_KaibutsuChase()
	{
		if ( args[0] )
		{
			sc++;
			if ( sc >= 16 ) sc = 0;
			if ( sc < 4 ) frame = 1;
			else if ( sc < 8 ) frame = 0;
			else if ( sc < 12 ) frame = 1;
			else if ( sc < 16 ) frame = 2;
			return;
		}
		if ( !target || (target.health <= 0) )
		{
			SetStateLabel("Idle");
			return;
		}
		if ( Random[KaibutsuLaugh]() < 3 )
			A_PlaySound("kaibutsu/giggle",CHAN_VOICE);
		if ( CheckMeleeRange() )
		{
			SetStateLabel("Melee");
			return;
		}
		sc++;
		if ( sc >= 8 ) sc = 0;
		if ( sc < 2 ) frame = 1;
		else if ( sc < 4 ) frame = 0;
		else if ( sc < 6 ) frame = 1;
		else if ( sc < 8 ) frame = 2;
		if ( (sc == 2) || (sc == 6) )
			mkFootstepMaker.PlayStep(self,1.0);
		// if we can't move towards them in a straight line
		// fall back to standard chase
		if ( CheckDirectMove() )
		{
			st = 0;
			A_FaceTarget(10);
			Vector2 dir = (cos(angle),sin(angle))*speed;
			TryMove(Vec2Offset(dir.x,dir.y),32);
		}
		else
		{
			A_Chase(null,null);
			if ( !IsVisible(target,true) && (++st > 30) )
			{
				A_FaceTarget();
				A_ClearTarget();
				SetStateLabel("Idle");
			}
		}
	}
	void A_KaibutsuWander()
	{
		if ( bSTANDSTILL ) return;
		sc++;
		if ( sc >= 16 ) sc = 0;
		if ( sc < 4 ) frame = 1;
		else if ( sc < 8 ) frame = 0;
		else if ( sc < 12 ) frame = 1;
		else if ( sc < 16 ) frame = 2;
		if ( sc == 4 || sc == 12 )
			mkFootstepMaker.PlayStep(self,0.5);
		A_Wander(CHF_NORANDOMTURN);
		wc--;
		if ( wc <= 0 )
			SetStateLabel("Idle");
	}
	States
	{
	Spawn:
		KAI1 B 0 NoDelay A_SetSkin();
		#### B 0 A_JumpIf(args[0],"See");
		Goto Idle;
	Idle:
		#### B 0 { sc = 0; wc = 25; }
		#### B 2
		{
			if ( !args[0] && (Random[KaibutsuLaugh]() < 2) )
				A_PlaySound("kaibutsu/giggle",CHAN_VOICE);
			A_Look();
			wc--;
			if ( wc <= 0 )
				return ResolveState("Wander");
			return ResolveState(null);
		}
		Wait;
	Wander:
		#### B 0 { sc = 0; wc = Random[Kaibutsu](1,3)*8; RandomChaseDir(); }
		#### # 2
		{
			if ( !args[0] && (Random[KaibutsuLaugh]() < 2) )
				A_PlaySound("kaibutsu/giggle",CHAN_VOICE);
			A_Look();
			A_KaibutsuWander();
		}
		Wait;
	See:
		#### B 0 { sc = 0; }
		#### # 2 A_KaibutsuChase();
		Wait;
	Melee:
		#### B 4 A_FaceTarget();
		#### B 4 A_KaibutsuBite();
		#### B 4 A_FaceTarget();
		Goto See;
	Skins:
		KAI1 A 0;
		KAI2 A 0;
		KAI3 A 0;
		Stop;
	}
}

Class KaibutsuNode : Actor
{
	// nearby nodes
	Array<KaibutsuNode> near;
	// pre-evaluated distance
	Array<double> weight;

	// underscore to prevent future breakage when PitchTo() PR is actually
	// merged
	double _PitchTo( Actor other )
	{
		Vector3 vecto = Vec3To(other);
		double dist = vecto.length();
		if ( dist > 0 ) return asin(vecto.z/dist);
		return 0;
	}

	bool, double CanReach( Actor other )
	{
		// first check is to exclude targets that aren't even visible
		// at all
		if ( !IsVisible(other,true) )
			return false, 0;
		// attempt to prevent room-over-room breakage by ignoring
		// target pitches that are "too steep" (over 45 degrees)
		if ( abs(_PitchTo(other)) > 45 )
			return false, 0;
		// target is very obviously reachable
		if ( Distance2D(other) < other.radius )
			return true, 0;
		// simulate kaibutsu moving towards goal to check path isn't
		// occluded
		let s = Spawn("CrowbarKaibutsu",pos);
		Vector2 vec = Vec2To(other);
		Vector2 dir = vec.unit()*s.speed;
		int divs = int(floor(vec.length()/s.speed));
		bool reachable = true;
		for ( int i=0; i<divs; i++ )
		{
			// unobstructed path, continue stepping
			if ( s.TryMove(s.Vec2Offset(dir.x,dir.y),32) )
				continue;
			// the target is obstructing movement, so that means we
			// reached it
			if ( s.BlockingMobj && (s.BlockingMobj == other) )
				break;
			reachable = false;
			break;
		}
		s.Destroy();
		return reachable, vec.length();
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		// locate neighboring nodes
		let ti = ThinkerIterator.Create("KaibutsuNode");
		KaibutsuNode n;
		if ( developer > 2 )
			Console.Printf("node at (% g, % g) locating neighbors:",pos.x,pos.y);
		while ( n = KaibutsuNode(ti.Next()) )
		{
			if ( n == self )
				continue;
			bool alreadyin = false;
			for ( int i=0; i<near.size(); i++ )
			{
				if ( near[i] != n )
					continue;
				alreadyin = true;
				break;
			}
			if ( alreadyin )
				continue;
			// evaluate reachability
			bool reachable;
			double dist;
			[reachable, dist] = CanReach(n);
			if ( !reachable )
				continue;
			near.Push(n);
			weight.Push(dist);
			if ( developer > 2 )
				Console.Printf(" (% g, % g)",n.pos.x,n.pos.y);
		}
	}

	Default
	{
		//$Title Kaibutsu Path Node
		//$Category Marisa Kirisame/dotFlow
		//$Sprite KAI4A1
		Radius 16;
		Height 56;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+DONTSPLASH;
	}
}

Class KaibutsuSightSpot : Actor
{
	Default
	{
		Radius 16;
		Height 56;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+DONTSPLASH;
	}
}

Class KaibutsuPathPlan
{
	// this plan's evaluated path
	Array<KaibutsuNode> path;
	// given cost / heuristic cost
	double g, h;
}

Class CrowbarKaibutsu : Actor
{
	int sc, wc;
	int lt;
	// spot auto-created when target goes out of sight
	// its angle is equal to the movement direction the target
	// had at that moment
	// the Kaibutsu will go for it and then see if the player
	// can be found
	// if not, it will go into search mode and immediately make
	// the closest search spot its goal
	Actor lastseen;
	// last visited node during search
	// and
	// the node we're currently trying to reach
	KaibutsuNode lastvisited;
	// list of nodes that this Kaibutsu will randomly visit while
	// searching for targets
	// the list is built from nodes whose tid is equal to this
	// Kaibutsu's score property
	Array<KaibutsuNode> searchnodes;
	// the full list of path nodes the Kaibutsu has to visit one
	// by one until reaching its goal
	Array<KaibutsuNode> fullpath;
	// current node index in the full path we're moving through
	int curnode;
	Default
	{
		//$Title Kaibutsu (Crowbar)
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.0;
		Radius 16;
		Height 56;
		Scale 2;
		Speed 12;
		Species "Kaibutsu";
		MONSTER;
		-COUNTKILL;
		+NODAMAGE;
		+SPRITEANGLE;
		+SLIDESONWALLS;
	}
	override void OnDestroy()
	{
		Super.OnDestroy();
		if ( lastseen )
			lastseen.Destroy();
	}
	void A_KaibutsuWander()
	{
		if ( bSTANDSTILL ) return;
		sc++;
		if ( sc >= 16 ) sc = 0;
		if ( sc < 4 ) frame = 1;
		else if ( sc < 8 ) frame = 0;
		else if ( sc < 12 ) frame = 1;
		else if ( sc < 16 ) frame = 2;
		if ( sc == 4 || sc == 12 )
			mkFootstepMaker.PlayStep(self,0.5);
		A_Wander(CHF_NORANDOMTURN);
		wc--;
		if ( wc <= 0 )
			SetStateLabel("Wander");
	}
	// A* stuff
	void BuildPath( KaibutsuPathPlan theplan, Actor goal )
	{
		curnode = 0;
		fullpath.Copy(theplan.path);
		// if final goal is a node, push it into the path
		// this usually shouldn't be needed
		if ( (goal is 'KaibutsuNode') && (fullpath[fullpath.Size()-1] != KaibutsuNode(goal)) )
			fullpath.Push(KaibutsuNode(goal));
		// debug
		if ( developer <= 2 ) return;
		Console.Printf("Building path:");
		for ( int i=0; i<fullpath.Size(); i++ )
			Console.Printf(" %d: (% g, % g)",i,fullpath[i].pos.x,fullpath[i].pos.y);
	}
	bool FindPath( Actor goal )
	{
		if ( developer > 2 )
			Console.Printf("Goal: %g %g",goal.pos.x,goal.pos.y);
		// is it directly reachable?
		if ( !(goal is 'KaibutsuNode') && IsVisible(goal,true) && CheckDirectMove(goal) )
		{
			if ( developer > 2 )
				Console.Printf("Target is directly reachable");
			return true;
		}
		KaibutsuNode startnode, goalnode;
		let ti = ThinkerIterator.Create("KaibutsuNode");
		KaibutsuNode n, found = null;
		// find closest node to goal (if not a node)
		if ( !(goal is 'KaibutsuNode') )
		{
			while ( n = KaibutsuNode(ti.Next()) )
			{
				bool reachable;
				double dist, mindist = double.infinity;
				[reachable, dist] = n.CanReach(goal);
				if ( !reachable ) continue;
				if ( dist > mindist ) continue;
				found = n;
				mindist = dist;
			}
			if ( !found )
			{
				if ( developer > 2 )
					Console.Printf("could not find goal node");
				return false;
			}
			goalnode = found;
			found = null;
			ti.Reinit();
		}
		else goalnode = KaibutsuNode(goal);
		while ( n = KaibutsuNode(ti.Next()) )
		{
			bool reachable;
			double dist, mindist = double.infinity;
			if ( !CheckDirectMove(n) )
				continue;
			dist = Distance2D(n);
			if ( dist > mindist ) continue;
			found = n;
			mindist = dist;
		}
		if ( !found )
		{
			if ( developer > 2 )
				Console.Printf("could not find start node");
			return false;
		}
		startnode = found;
		if ( developer > 2 )
			Console.Printf("start: (% g, % g), end: (% g, % g)",startnode.pos.x,startnode.pos.y,goalnode.pos.x,goalnode.pos.y);
		// Begin A* proper
		// Most of the implementation taken from https://forum.zdoom.org/viewtopic.php?f=105&t=58168
		Array<KaibutsuPathPlan> fringe;
		fringe.Push(new("KaibutsuPathPlan"));
		fringe[0].path.Push(startnode);
		fringe[0].g = Distance2D(startnode);
		fringe[0].h = startnode.Distance2D(goal);
		Array<KaibutsuNode> closed;
		while ( fringe.Size() > 0 )
		{
			KaibutsuPathPlan cur = fringe[0];
			fringe[0] = fringe[fringe.Size()-1];
			fringe.Pop();
			// something something trickling and heaps
			int i = 0;
			int ch1 = 1;
			int ch2 = 2;
			while ( fringe.Size() > ch1 )
			{
				double cost = fringe[i].g+fringe[i].h;
				double ch1cost = fringe[ch1].g+fringe[ch1].h;
				int mini = i;
				if ( fringe.Size() > ch2 )
				{
					double ch2cost = fringe[ch2].g+fringe[ch2].h;
					if ( (ch2cost < ch1cost) && (ch2cost < cost) )
						mini = ch2;
					else if ( ch1cost < cost )
						mini = ch1;
				}
				else if ( ch1cost < cost )
					mini = ch1;
				// swap
				if ( i != mini )
				{
					KaibutsuPathPlan tmp = fringe[i];
					fringe[i] = fringe[mini];
					fringe[mini] = tmp;
					i = mini;
					ch1 = 2*i+1;
					ch2 = ch1+1;
				}
				else break;
			}
			// goal reached? build path
			KaibutsuNode lastnode = cur.path[cur.path.Size()-1];
			if ( lastnode == goalnode )
			{
				BuildPath(cur,goal);
				return true;
			}
			// no good, close it
			closed.Push(lastnode);
			// spread out to neighbors
			int nc = lastnode.near.Size();
			for ( int j=0; j<nc; j++ )
			{
				// don't pass through closed nodes
				int ci = closed.Find(lastnode.near[j]);
				// can't remember whether Find returns -1 or
				// the array size when not finding an element
				// so will check for both
				if ( (ci != -1) && (ci < closed.Size()) )
					continue;
				// new plan
				fringe.Push(new("KaibutsuPathPlan"));
				int i = fringe.Size()-1;
				fringe[i].path.Copy(cur.path);
				fringe[i].path.Push(lastnode.near[j]);
				fringe[i].g = cur.g+lastnode.weight[j];
				fringe[i].h = lastnode.near[j].Distance2D(goal);
				// something about bubbles rising up in cost?
				while ( i > 0 )
				{
					int pi = (i-1)/2;
					double cost = fringe[i].g+fringe[i].h;
					double pcost = fringe[pi].g+fringe[pi].h;
					// swap
					if ( pcost > cost )
					{
						KaibutsuPathPlan tmp = fringe[i];
						fringe[i] = fringe[pi];
						fringe[pi] = tmp;
						i = pi;
					}
					else break;
				}
			}
		}
		if ( developer > 2 )
			Console.Printf("could not create valid path");
		return false;
	}
	override void Activate( Actor activator )
	{
		// see if there's a path to the activator
		// and go investigate
		if ( !activator ) return;
		FindPath(activator);
		SetStateLabel("Search");
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if ( score == 0 )
			return;
		let ti = ThinkerIterator.Create("KaibutsuNode");
		KaibutsuNode n;
		while ( n = KaibutsuNode(ti.Next()) )
		{
			if ( n.tid != score ) continue;
			searchnodes.Push(n);
		}
	}
	override void Tick()
	{
		Super.Tick();
		double angdiff = deltaangle(AngleTo(players[consoleplayer].camera),angle);
		if ( abs(angdiff) <= 45 ) spriteangle = 180;
		else if ( abs(angdiff) >= 135 ) spriteangle = 0;
		else if ( angdiff > 45 ) spriteangle = 90;
		else if ( angdiff < -45 ) spriteangle = 270;
		if ( InStateSequence(CurState,FindState("Search")) || InStateSequence(CurState,FindState("Wander")) ) speed = 4;
		else speed = 12;
	}
	bool CheckDirectMove( Actor other = null )
	{
		if ( !other ) other = target;
		// check if we can move towards target without bumping into anything
		Vector3 oldpos = pos;
		double angdest = AngleTo(other);
		Vector2 dir = (cos(angdest),sin(angdest))*speed;
		int steps = int(floor(Vec2To(other).length()/speed));
		for ( int i=0; i<steps; i++ )
		{
			if ( TryMove(Vec2Offset(dir.x,dir.y),32) )
				continue;
			if ( BlockingMobj == other )
				break;
			SetOrigin(oldpos,false);
			return false;
		}
		SetOrigin(oldpos,false);
		return true;
	}
	void A_KaibutsuChase()
	{
		if ( !target || (target.health <= 0) )
		{
			SetStateLabel("Idle");
			return;
		}
		if ( Random[KaibutsuLaugh]() < 6 )
			A_PlaySound("kaibutsu/giggle",CHAN_VOICE);
		if ( CheckMeleeRange() )
		{
			if ( !target.player || !(target.player.cheats&CF_TOTALLYFROZEN) )
				SetStateLabel("Melee");
			return;
		}
		sc++;
		if ( sc >= 8 ) sc = 0;
		if ( sc < 2 ) frame = 1;
		else if ( sc < 4 ) frame = 0;
		else if ( sc < 6 ) frame = 1;
		else if ( sc < 8 ) frame = 2;
		if ( sc == 2 || sc == 6 )
			mkFootstepMaker.PlayStep(self,1.0);
		// if we can't move towards them in a straight line
		// use normal chase
		if ( !lastseen )
			lastseen = Spawn("KaibutsuSightSpot");
		lastseen.SetOrigin(target.pos,false);
		if ( target.vel.xy.length() > 0 )
		{
			Vector2 mdir = target.vel.xy.unit();
			lastseen.angle = atan2(mdir.y,mdir.x);
		}
		else lastseen.angle = angle;
		if ( CheckDirectMove() )
		{
			A_FaceTarget(10);
			Vector2 dir = (cos(angle),sin(angle))*speed;
			TryMove(Vec2Offset(dir.x,dir.y),32);
		}
		else A_Chase(null,null);
		// if we can no longer see the target anymore, search the last spot they were at
		if ( !IsVisible(target,true) && lastseen )
		{
			if ( lt++ < 30 )
				return;
			if ( !CheckDirectMove(target) )
				FindPath(target);
			SetStateLabel("Search");
		}
		lt = 0;
	}
	void A_KaibutsuSearch()
	{
		if ( (target && IsVisible(target,false)) || LookForPlayers(false) )
		{
			// quit searching if we can see a target
			if ( developer > 2 )
				Console.Printf("Target found, interrupting search");
			fullpath.Clear();
			if ( lastseen )
				lastseen.Destroy();
			SetStateLabel("See");
			return;
		}
		if ( fullpath.Size() > 0 )
		{
			// if we have a path to follow, go to the current node
			if ( Distance3D(fullpath[curnode]) < radius )
			{
				// node reached, switch to next
				if ( developer > 2 )
					Console.Printf("Node %d reached",curnode);
				SetOrigin(fullpath[curnode].pos,true);
				curnode++;
				// end of the line
				if ( curnode >= fullpath.Size() )
				{
					lastvisited = fullpath[fullpath.Size()-1];
					fullpath.Clear();
					return;
				}
			}
			A_Face(fullpath[curnode]);
		}
		else if ( lastseen )
		{
			// if we have a "last seen spot", move towards it
			if ( Distance3D(lastseen) < speed )
			{
				// destination reached, wait and see
				if ( developer > 2 )
					Console.Printf("Last seen spot reached");
				SetOrigin(lastseen.pos,true);
				angle = lastseen.angle;
				lastseen.Destroy();
				lastseen = null;
				return;
			}
			A_Face(lastseen);
		}
		else
		{
			// end of path
			if ( developer > 2 )
				Console.Printf("Waiting");
			SetStateLabel("SearchWait");
			return;
		}
		// just step
		sc++;
		if ( sc >= 16 ) sc = 0;
		if ( sc < 4 ) frame = 1;
		else if ( sc < 8 ) frame = 0;
		else if ( sc < 12 ) frame = 1;
		else if ( sc < 16 ) frame = 2;
		if ( sc == 4 || sc == 12 )
			mkFootstepMaker.PlayStep(self,0.5);
		Vector2 dir = (cos(angle),sin(angle))*speed;
		if ( !TryMove(Vec2Offset(dir.x,dir.y),32) )
		{
			if ( developer > 2 )
				Console.Printf("path obstructed, waiting");
			SetStateLabel("SearchWait");
		}
	}
	void A_KaibutsuSwing()
	{
		A_FaceTarget(10);
		A_PlaySound("skeleton/swing",CHAN_WEAPON);
	}
	void A_KaibutsuMelee()
	{
		A_FaceTarget(10);
		if ( !target )
			return;
		double ang = AngleTo(target);
		meleerange += 50;
		if ( !CheckMeleeRange() || abs(deltaangle(angle,ang)) > 45 )
		{
			meleerange -= 50;
			return;
		}
		meleerange -= 50;
		A_PlaySound("skeleton/melee",CHAN_WEAPON);
		int dmg = Random[Kaibutsu](7,9)*3;
		int ndmg = target.DamageMobj(self,self,dmg,'Melee');
		target.TraceBleed((ndmg>0)?ndmg:dmg,self);
	}
	States
	{
	Spawn:
		KAI4 B 1
		{
			alpha += 0.1;
			if ( alpha >= 1.0 )
			{
				A_SetRenderstyle(1.0,STYLE_Normal);
				return ResolveState("Idle");
			}
			return ResolveState(null);
		}
		Wait;
	Idle:
		KAI4 B 10;
		Goto Wander;
	See:
		KAI4 B 0 { sc = 0; }
		KAI4 # 2 A_KaibutsuChase();
		Wait;
	Search:
		KAI4 B 0 { sc = 0; }
		KAI4 # 2 A_KaibutsuSearch();
		Wait;
	SearchWait:
		KAI4 B 0 { sc = 10; }
		KAI4 B 10
		{
			A_Look();
			sc--;
			if ( sc <= 0 )
			{
				// nothing found, forget target
				A_ClearTarget();
				// no search nodes, just idle
				if ( searchnodes.Size() <= 0 )
					return ResolveState("Wander");
				int newindex = Random[Kaibutsu](0,searchnodes.Size()-2);
				int oldindex = searchnodes.Find(lastvisited);
				if ( newindex >= oldindex )
					newindex += 1;
				FindPath(searchnodes[newindex]);
				if ( fullpath.Size() > 0 )
				{
					if ( developer > 2 )
						Console.Printf("Investigating node (% g, % g)",searchnodes[newindex].pos.x,searchnodes[newindex].pos.y);
					return ResolveState("Search");
				}
				// can't make path, just wander
				return ResolveState("Wander");
			}
			return ResolveState(null);
		}
		Wait;
	Melee:
		KAI4 B 0 { sc = 0; }
		KAI4 D 5 A_FaceTarget();
		KAI4 E 4 A_KaibutsuSwing();
		KAI4 F 4 A_FaceTarget(10);
		KAI4 G 6 A_KaibutsuMelee();
		KAI4 D 5 A_FaceTarget(10);
		Goto See;
	Wander:
		#### B 100
		{
			sc = 0;
			wc = Random[Kaibutsu](1,3)*8;
			if ( searchnodes.Size() > 0 )
			{
				// try to search
				int newindex = Random[Kaibutsu](0,searchnodes.Size()-2);
				int oldindex = searchnodes.Find(lastvisited);
				if ( newindex >= oldindex )
					newindex += 1;
				FindPath(searchnodes[newindex]);
				if ( fullpath.Size() > 0 )
				{
					if ( developer > 2 )
						Console.Printf("Investigating node (% g, % g)",searchnodes[newindex].pos.x,searchnodes[newindex].pos.y);
					return ResolveState("Search");
				}
			}
			RandomChaseDir();
			return ResolveState(null);
		}
		#### # 2
		{
			if ( Random[KaibutsuLaugh]() < 2 )
				A_PlaySound("kaibutsu/giggle",CHAN_VOICE);
			A_Look();
			A_KaibutsuWander();
		}
		Wait;
	}
}

Class SmilingSabitsuki : Actor
{
	Default
	{
		//$Title Smiling Sabitsuki
		//$Category Marisa Kirisame/dotFlow
		Radius 16;
		Height 56;
		Scale 2;
		+SOLID;
	}
	States
	{
	Spawn:
		KAI5 A -1;
		Stop;
	}
}

Class KneelingSabitsuki : Actor
{
	Default
	{
		//$Title Kneeling Sabitsuki
		//$Category Marisa Kirisame/dotFlow
		Radius 16;
		Height 56;
		Scale 2;
		+SOLID;
	}
	States
	{
	Spawn:
		KAI6 A -1;
		Stop;
	}
}

Class SchoolKid : Actor
{
	int sc, wc;
	Default
	{
		//$Title School Kid
		//$Category Marisa Kirisame/dotFlow
		//$Sprite KID1B0
		Radius 8;
		Height 36;
		Scale 1.5;
		Speed 4;
		MONSTER;
		-COUNTKILL;
		-ISMONSTER;
		+NODAMAGE;
		+SLIDESONWALLS;
	}
	void A_SchoolKidWander()
	{
		if ( bSTANDSTILL ) return;
		sc++;
		if ( sc >= 8 ) sc = 0;
		if ( sc < 2 ) frame = 1;
		else if ( sc < 4 ) frame = 0;
		else if ( sc < 6 ) frame = 1;
		else if ( sc < 8 ) frame = 2;
		if ( sc == 2 || sc == 6 )
			mkFootstepMaker.PlayStep(self,0.2);
		A_Wander(CHF_NORANDOMTURN);
		wc--;
		if ( wc <= 0 )
			SetStateLabel("Idle");
	}
	void A_SetSkin()
	{
		int dec = Random[Kid](0,1);
		if ( score ) dec = score-1;
		if ( dec == 1 ) sprite = GetSpriteIndex('KID2');
		else sprite = GetSpriteIndex('KID1');
	}
	States
	{
	Spawn:
		KID1 B 0 NoDelay A_SetSkin();
		Goto Idle;
	Idle:
		#### B 100 { sc = 0; wc = Random[Kid](1,3)*8; RandomChaseDir(); }
		#### # 2 A_SchoolKidWander();
		Wait;
	Skins:
		KID1 B 0;
		KID2 B 0;
		Stop;
	}
}

Class Smile : Actor
{
	int sc;
	override void Tick()
	{
		Super.Tick();
		double angdiff = deltaangle(AngleTo(players[consoleplayer].camera),angle);
		if ( abs(angdiff) <= 45 ) spriteangle = 180;
		else if ( abs(angdiff) >= 135 ) spriteangle = 0;
		else if ( angdiff > 45 ) spriteangle = 90;
		else if ( angdiff < -45 ) spriteangle = 270;
	}
	Default
	{
		//$Title Smile
		//$Category Marisa Kirisame/dotFlow
		Radius 16;
		Height 56;
		Scale 2;
		Speed 15;
		MONSTER;
		-COUNTKILL;
		-ISMONSTER;
		+NODAMAGE;
		+STANDSTILL;
		+SPRITEANGLE;
		+SLIDESONWALLS;
	}
	bool CheckDirectMove()
	{
		// check if we can move towards target without bumping into anything
		Vector3 oldpos = pos;
		double angdest = AngleTo(target);
		Vector2 dir = (cos(angdest),sin(angdest))*speed;
		for ( int i=0; i<4; i++ )
		{
			if ( TryMove(Vec2Offset(dir.x,dir.y),32) )
				continue;
			if ( BlockingMobj == target )
				break;
			SetOrigin(oldpos,false);
			return false;
		}
		SetOrigin(oldpos,false);
		return true;
	}
	void A_KaibutsuChase()
	{
		if ( !target || (target.health <= 0) )
		{
			SetStateLabel("Spawn");
			return;
		}
		// if we can't move towards them in a straight line
		// fall back to standard chase
		if ( CheckMeleeRange() )
		{
			SpooktoberUtil.FullFreeze(target);
			mkSmoothLookTo.LookTowards(target,target.AngleTo(self),0,4.0);
			SetStateLabel("Melee");
			return;
		}
		sc++;
		if ( sc >= 8 ) sc = 0;
		if ( sc < 2 ) frame = 1;
		else if ( sc < 4 ) frame = 0;
		else if ( sc < 6 ) frame = 1;
		else if ( sc < 8 ) frame = 2;
		if ( sc == 2 || sc == 6 )
			mkFootstepMaker.PlayStep(self,1.0);
		if ( IsVisible(target,false) && CheckDirectMove() )
		{
			A_FaceTarget(10);
			Vector2 dir = (cos(angle),sin(angle))*speed;
			TryMove(Vec2Offset(dir.x,dir.y),32);
		}
		else A_Chase(null,null);
	}
	void A_KaibutsuSwing()
	{
		A_FaceTarget();
		A_PlaySound("skeleton/swing",CHAN_WEAPON);
	}
	void A_KaibutsuMelee()
	{
		A_FaceTarget();
		A_PlaySound("skeleton/melee",CHAN_WEAPON);
		SpooktoberHandler.DoKnockOut();
	}
	States
	{
	Spawn:
		SMIL B 4 A_Look();
		Wait;
	See:
		SMIL B 0 { sc = 0; }
		SMIL # 2 A_KaibutsuChase();
		Wait;
	Melee:
		SMIL B 5 A_JumpIf(abs(deltaangle(target.AngleTo(self),target.angle))<10,1);
		Wait;
		SMIL F 5 A_FaceTarget();
		SMIL G 4 A_KaibutsuSwing();
		SMIL H 4 A_FaceTarget();
		SMIL I 6 A_KaibutsuMelee();
		SMIL F 5 A_FaceTarget();
		SMIL B 70;
		SMIL B 100 A_PlaySound("misc/wwww2",CHAN_VOICE,1.0,false,ATTN_NONE);
		SMIL B -1 ACS_NamedExecute('MapFadeOut');
		Stop;
	}
}

Class Smile2 : Smile
{
	bool wasused;
	int seetime;

	Default
	{
		//$Title Smile (Cutscene)
		//$Category Marisa Kirisame/dotFlow
	}
	private bool InPlayerLOS( int p )
	{
		let mo = players[p].mo;
		Vector3 sc = level.SphericalCoords(mo.pos,pos,(mo.angle,mo.pitch));
		return ((abs(sc.x)<90)||(abs(sc.y)>60))&&CheckSight(mo);
	}
	private bool CanSeePlayers()
	{
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] )
				continue;
			if ( CheckSight(players[i].mo) )
				return true;
		}
		return false;
	}
	override void Tick()
	{
		Super.Tick();
		if ( !bAMBUSH || !InStateSequence(CurState,FindState("Spawn")) )
			return;
		bool seen = false;
		Actor seeplayer = null;
		// check if any players are looking at us
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] )
				continue;
			if ( InPlayerLOS(i) )
			{
				seen = true;
				seeplayer = players[i].mo;
				break;
			}
		}
		if ( seen ) seetime++;
		else seetime = 0;
		if ( seetime > 200 )
			Activate(seeplayer);
	}
	override void Activate( Actor activator )
	{
		if ( !InStateSequence(CurState,FindState("Spawn")) )
			return;
		target = activator;
		SetStateLabel("Turn");
		return;
	}
	override bool Used( Actor user )
	{
		if ( !InStateSequence(CurState,FindState("Spawn")) )
			return true;
		target = user;
		wasused = true;
		SpooktoberUtil.FullFreeze(null);
		mkSmoothLookTo.LookTowards(target,target.AngleTo(self),0,4.0);
		S_ChangeMusic("");
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] )
				continue;
			players[i].camera = target;
		}
		SetStateLabel("Turn");
		return true;
	}
	void A_Smile()
	{
		A_PlaySound("smile/laugh",CHAN_BODY,1.0,false,ATTN_NONE);
		A_PlaySound("smile/laugh",CHAN_VOICE,1.0,false,ATTN_NONE);
		A_PlaySound("misc/wwww2",CHAN_ITEM,0.3,false,ATTN_NONE);
		A_QuakeEx(5,5,5,40,0,65535,"",QF_SCALEDOWN|QF_RELATIVE);
		SpooktoberHandler.DoSmile();
	}
	States
	{
	Spawn:
		SMIL B -1;
		Stop;
	Turn:
		SMIL B 4
		{
			A_FaceTarget(30);
			if ( abs(deltaangle(angle,AngleTo(target))) <= 15 )
			{
				if ( wasused )
					return ResolveState("Melee");
				return ResolveState("Laugh");
			}
			return ResolveState(null);
		}
		Wait;
	Laugh:
		SMIL BB 5 A_FaceTarget();
		SMIL D 15;
		SMIL E 40 A_Smile();
		SMIL B 5
		{
			A_FaceTarget();
			seetime--;
			return A_JumpIf((seetime<=0)&&!CanSeePlayers(),1);
		}
		Wait;
		SMIL B 0
		{
			bAMBUSH = true;
			angle = spawnangle;
		}
		Goto Spawn;
	}
}

Class FleshPost1 : Actor
{
	Default
	{
		//$Title Flesh Post 1
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 16;
		Height 64;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FPIL B -1;
		Stop;
	}
}

Class FleshPost2 : Actor
{
	Default
	{
		//$Title Flesh Post 2
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 16;
		Height 64;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FPIL B -1;
		Stop;
	}
}

Class FleshBeast1 : Actor
{
	Default
	{
		//$Title Flesh Beast 1
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 24;
		Height 64;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FMON A -1;
		Stop;
	}
}

Class FleshBeast2 : Actor
{
	Default
	{
		//$Title Flesh Beast 2
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 24;
		Height 64;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FMON B -1;
		Stop;
	}
}

Class FleshBeast3 : Actor
{
	Default
	{
		//$Title Flesh Beast 3
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 32;
		Height 64;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FMON C -1;
		Stop;
	}
}

Class FleshBeast4 : Actor
{
	Default
	{
		//$Title Flesh Beast 4
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 40;
		Height 64;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FMON D -1;
		Stop;
	}
}

Class SchoolTable : Actor
{
	Default
	{
		//$Title School Table
		//$Category Marisa Kirisame/dotFlow
		Radius 20;
		Height 26;
		Scale 2;
		Mass int.max;
		+SOLID;
		+SHOOTABLE;
		+NODAMAGE;
		+NOBLOOD;
		+DONTTHRUST;
	}
	States
	{
	Spawn:
		TABL A -1;
		Stop;
	}
}

Class SchoolTableChair : Actor
{
	Default
	{
		//$Title School Table (Chair)
		//$Category Marisa Kirisame/dotFlow
		Radius 20;
		Height 26;
		Scale 2;
		Mass int.max;
		+SOLID;
		+SHOOTABLE;
		+NODAMAGE;
		+NOBLOOD;
		+DONTTHRUST;
	}
	States
	{
	Spawn:
		TABL B -1;
		Stop;
	}
}

Class FloorBlood1 : Actor
{
	Default
	{
		//$Title Floor Blood 1
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+FLATSPRITE;
	}
	States
	{
	Spawn:
		FBLD A -1;
		Stop;
	}
}

Class FloorBlood2 : Actor
{
	Default
	{
		//$Title Floor Blood 2
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+FLATSPRITE;
	}
	States
	{
	Spawn:
		FBLD B -1;
		Stop;
	}
}

Class FloorEye : Actor
{
	Default
	{
		//$Title Floor Eye
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+FLATSPRITE;
		+MOVEWITHSECTOR;
	}
	States
	{
	Spawn:
		FEYE A -1;
		Stop;
	}
}

Class FleshBanner1 : Actor
{
	Default
	{
		//$Title Flesh Banner 1
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FBAN A -1;
		Stop;
	}
}

Class FleshBanner2 : Actor
{
	Default
	{
		//$Title Flesh Banner 2
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		FBAN B -1;
		Stop;
	}
}

Class RedDemon : Actor
{
	int dashcnt;
	Default
	{
		//$Title Red Demon
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.0;
		Scale 2.0;
		Radius 16;
		Height 56;
		Speed 5;
		DamageFunction Random[Red](3,9);
		MONSTER;
		-COUNTKILL;
		+NODAMAGE;
		+SLIDESONWALLS;
		+LOOKALLAROUND;
	}
	bool A_RedChase()
	{
		if ( !target || !CheckSight(target) )
		{
			A_Wander();
			return true;
		}
		if ( CheckMeleeRange() && (!target.player || !(target.player.cheats&CF_TOTALLYFROZEN)) )
		{
			target.DamageMobj(self,self,GetMissileDamage(0,0),'Melee',DMG_THRUSTLESS);
			target.A_Stop();
			target.A_SetBlend("Red",1.0,5);
			target.A_PlaySound("red/noise",CHAN_ITEM);
			Destroy();
			return false;
		}
		A_Chase(null,null);
		return true;
	}
	void A_RedDemonThink()
	{
		double mindist = double.infinity;
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( !playeringame[i] || (players[i].mo.Health <= 0) )
				continue;
			double dist = Distance2D(players[i].mo);
			if ( dist > mindist )
				continue;
			mindist = dist;
			target = players[i].mo;
		}
		if ( !A_RedChase() )
			return;
		if ( !target || !CheckSight(target) )
			return;
		if ( dashcnt > 0 )
		{
			for ( int i=0; i<3; i++ )
				if ( !A_RedChase() )
					return;
			dashcnt--;
		}
		else if ( !Random[Red](0,10) )
			dashcnt = Random[Red](3,6);
	}
	States
	{
	Spawn:
		RED1 B 1
		{
			alpha += 0.1;
			if ( alpha >= 1.0 )
			{
				A_SetRenderstyle(1.0,STYLE_Normal);
				return ResolveState("Idle");
			}
			return ResolveState(null);
		}
		Wait;
	Idle:
		RED1 BBAABBCC 2 A_RedDemonThink();
		Loop;
	}
}

Class RedDemonBig : RedDemon
{
	Default
	{
		//$Title Red Demon (Big)
		//$Category Marisa Kirisame/dotFlow
		//$Sprite RED2B0
		Speed 3;
		DamageFunction (Random[Red](3,9)*3);
		-SOLID;
	}
	States
	{
	Spawn:
		TNT1 A 4 A_LookEx(0,0,300,300,0,"Rise");
		Wait;
	Rise:
		RED2 D 0 { bSOLID = true; }
		RED2 DEFG 3;
		Goto See;
	See:
		RED2 BBAABBCC 2 A_RedDemonThink();
		Loop;
	}
}

Class RooftopSmile : Actor
{
	Default
	{
		//$Title Rooftop Smile
		//$Category Marisa Kirisame/dotFlow
		Scale 2.0;
	}
	States
	{
	Spawn:
		BSMI BABC 4;
		Loop;
	}
}

Class FleshTree1 : Actor
{
	Default
	{
		//$Title Flesh Tree 1
		//$Category Marisa Kirisame/dotFlow
		Scale 2.0;
		Radius 32;
		Height 96;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
	}
	States
	{
	Spawn:
		FTRE A -1;
		Stop;
	}
}

Class FleshTree2 : Actor
{
	Default
	{
		//$Title Flesh Tree 2
		//$Category Marisa Kirisame/dotFlow
		Scale 2.0;
		Radius 24;
		Height 96;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
	}
	States
	{
	Spawn:
		FTRE B -1;
		Stop;
	}
}

Class FleshTree3 : Actor
{
	Default
	{
		//$Title Flesh Tree 3
		//$Category Marisa Kirisame/dotFlow
		Scale 2.0;
		Radius 16;
		Height 96;
		Mass int.max;
		+SOLID;
		+DONTTHRUST;
	}
	States
	{
	Spawn:
		FTRE C -1;
		Stop;
	}
}

Class WallEye : Actor
{
	Default
	{
		//$Title Wall Eye
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		WEYE A 10;
		WEYE A 10 A_Jump(16,"Blink");
		Loop;
	Blink:
		WEYE BCD 4;
		WEYE E 8;
		WEYE DCB 4;
		Goto Spawn;
	Pain:
		WEYE G 4;
		Goto Spawn;
	Death:
		WEYE F -1;
		Stop;
	}
}

Class WallMouth : Actor
{
	Default
	{
		//$Title Wall Mouth
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	private bool InPlayerLOS( int p )
	{
		let mo = players[p].mo;
		Vector3 sc = level.SphericalCoords(mo.pos,pos,(mo.angle,mo.pitch));
		return (abs(sc.x)<90)||(abs(sc.y)>60);
	}
	States
	{
	Spawn:
		WMOU A 20
		{
			bool seeplayers = true;
			bool seenbyplayers = false;
			for ( int i=0; i<MAXPLAYERS; i++ )
			{
				if ( !playeringame[i] )
					continue;
				if ( !CheckSight(players[i].mo) )
				{
					seeplayers = false;
					break;
				}
				if ( !InPlayerLOS(i) )
					continue;
				seenbyplayers = true;
				break;
			}
			if ( seeplayers && !seenbyplayers && (Random[Kaibutsu]() < 6) )
				A_PlaySound("kaibutsu/giggle",CHAN_BODY,0.5);
		}
		Wait;
	}
}

Class MouthBanner1 : Actor
{
	Default
	{
		//$Title Mouth Banner 1
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN A -1;
		Stop;
	}
}

Class MouthBanner2 : Actor
{
	Default
	{
		//$Title Mouth Banner 2
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN B -1;
		Stop;
	}
}

Class MouthBanner3 : Actor
{
	Default
	{
		//$Title Mouth Banner 3
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN C -1;
		Stop;
	}
}

Class MouthBanner4 : Actor
{
	Default
	{
		//$Title Mouth Banner 4
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN D -1;
		Stop;
	}
}

Class MouthBanner5 : Actor
{
	Default
	{
		//$Title Mouth Banner 5
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN E -1;
		Stop;
	}
}

Class MouthBanner6 : Actor
{
	Default
	{
		//$Title Mouth Banner 6
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN F -1;
		Stop;
	}
}

Class EyeBanner1 : Actor
{
	Default
	{
		//$Title Eye Banner 1
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN G -1;
		Stop;
	}
}

Class EyeBanner2 : Actor
{
	Default
	{
		//$Title Eye Banner 2
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Scale 2.0;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	States
	{
	Spawn:
		SBAN H -1;
		Stop;
	}
}

Class SkyEye : Actor
{
	double cn;
	Default
	{
		//$Title Sky Eye
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+INTERPOLATEANGLES;
		+WALLSPRITE;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if ( args[0] )
			return;
		for ( int i=1; i<3; i++ )
		{
			let s = Spawn("SkyEye",SpawnPoint);
			s.args[0] = 120*i;
		}
	}
	void A_Orbit()
	{
		Vector3 dir = (cos(cn+args[0]),sin(cn+args[0]),0)*150;
		SetOrigin(level.Vec3Offset(SpawnPoint,dir),true);
		angle = cn+args[0];
		cn += 0.02;
	}
	States
	{
	Spawn:
		EYED A 1 Bright A_Orbit();
		Wait;
	}
}

Class SkyCross : Actor
{
	double cn;
	Default
	{
		//$Title Sky Cross
		//$Category Marisa Kirisame/dotFlow
		RenderStyle "Translucent";
		Alpha 0.999999;
		Radius 1;
		Height 0.1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEYBILLBOARD;
		+WALLSPRITE;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if ( args[0] )
			return;
		for ( int i=1; i<4; i++ )
		{
			let s = Spawn("SkyCross",SpawnPoint);
			s.args[0] = 90*i;
		}
	}
	void A_Orbit()
	{
		Vector3 dir = (cos(cn+args[0]),sin(cn+args[0]),0)*200;
		SetOrigin(level.Vec3Offset(SpawnPoint,dir),true);
		angle = cn+args[0];
		cn += 0.03;
	}
	States
	{
	Spawn:
		CROS A 1 Bright A_Orbit();
		Wait;
	}
}

Class BlackCard : DoomKey
{
	Default
	{
		Inventory.PickupMessage "Picked up a black keycard.";
		Inventory.Icon "STKEYBLK";
	}
	States
	{
	Spawn:
		DKEY A 10;
		DKEY B 10 Bright;
		Loop;
	}
}

Class WhiteCard : DoomKey
{
	Default
	{
		Inventory.PickupMessage "Picked up a white keycard.";
		Inventory.Icon "STKEYWHT";
	}
	States
	{
	Spawn:
		WKEY A 10;
		WKEY B 10 Bright;
		Loop;
	}
}

Class Cleaner : Actor
{
	Default
	{
		//$Title Cleaner
		//$Category Marisa Kirisame/dotFlow
		Radius 16;
		Height 56;
		Scale 2;
		+SOLID;
		+SPRITEANGLE;
	}
	override void Tick()
	{
		Super.Tick();
		double angdiff = deltaangle(AngleTo(players[consoleplayer].camera),angle);
		if ( abs(angdiff) <= 45 ) spriteangle = 180;
		else if ( abs(angdiff) >= 135 ) spriteangle = 0;
		else if ( angdiff > 45 ) spriteangle = 90;
		else if ( angdiff < -45 ) spriteangle = 270;
	}
	override bool Used( Actor user )
	{
		if ( !InStateSequence(CurState,FindState("Spawn")) )
			return true;
		target = user;
		SetStateLabel("Bow");
		return true;
	}
	States
	{
	Spawn:
		CLEN A -1;
		Stop;
	Bow:
		CLEN A 0 A_FaceTarget();
		CLEN ABCD 4;
		CLEN E 12;
		CLEN DCBA 4;
		CLEN A 0 A_SetAngle(SpawnAngle);
		Goto Spawn;
	}
}
